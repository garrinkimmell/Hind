module Language.KansasLava.Verification.SAL.SAL_DTD where

import Text.XML.HaXml.XmlContent
import Text.XML.HaXml.OneOfN


{-Type decls-}

data CONTEXT = CONTEXT CONTEXT_Attrs IDENTIFIER PARAMETERS
                       CONTEXTBODY
             deriving (Eq,Show)
data CONTEXT_Attrs = CONTEXT_Attrs
    { cONTEXTPLACE :: (Maybe String)
    , cONTEXTLOGIC :: (Defaultable CONTEXT_LOGIC)
    } deriving (Eq,Show)
data CONTEXT_LOGIC = CONTEXT_LOGIC_YES  |  CONTEXT_LOGIC_NO
                   deriving (Eq,Show)
data PARAMETERS = PARAMETERS PARAMETERS_Attrs (Maybe TYPEDECLS)
                             (Maybe VARDECLS)
                deriving (Eq,Show)
data PARAMETERS_Attrs = PARAMETERS_Attrs
    { pARAMETERSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data TYPEDECLS = TYPEDECLS TYPEDECLS_Attrs [TYPEDECL]
               deriving (Eq,Show)
data TYPEDECLS_Attrs = TYPEDECLS_Attrs
    { tYPEDECLSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data VARDECLS = VARDECLS VARDECLS_Attrs [VARDECL]
              deriving (Eq,Show)
data VARDECLS_Attrs = VARDECLS_Attrs
    { vARDECLSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data CONTEXTBODY = CONTEXTBODY CONTEXTBODY_Attrs
                               (List1 CONTEXTBODY_)
                 deriving (Eq,Show)
data CONTEXTBODY_Attrs = CONTEXTBODY_Attrs
    { cONTEXTBODYPLACE :: (Maybe String)
    } deriving (Eq,Show)
data CONTEXTBODY_ = CONTEXTBODY_CONSTANTDECLARATION CONSTANTDECLARATION
                  | CONTEXTBODY_TYPEDECLARATION TYPEDECLARATION
                  | CONTEXTBODY_ASSERTIONDECLARATION ASSERTIONDECLARATION
                  | CONTEXTBODY_CONTEXTDECLARATION CONTEXTDECLARATION
                  | CONTEXTBODY_MODULEDECLARATION MODULEDECLARATION
                  deriving (Eq,Show)
data CONSTANTDECLARATION = CONSTANTDECLARATION CONSTANTDECLARATION_Attrs
                                               IDENTIFIER
                                               (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
                                               (Maybe ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)))
                         deriving (Eq,Show)
data CONSTANTDECLARATION_Attrs = CONSTANTDECLARATION_Attrs
    { cONSTANTDECLARATIONPLACE :: (Maybe String)
    , cONSTANTDECLARATIONFUNCTIONAL :: (Defaultable CONSTANTDECLARATION_FUNCTIONAL)
    } deriving (Eq,Show)
data CONSTANTDECLARATION_FUNCTIONAL = CONSTANTDECLARATION_FUNCTIONAL_YES
                                       |  CONSTANTDECLARATION_FUNCTIONAL_NO
                                    deriving (Eq,Show)
data TYPEDECLARATION = TYPEDECLARATION TYPEDECLARATION_Attrs
                                       IDENTIFIER
                                       (Maybe ((OneOf3 (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE) SCALARTYPE DATATYPE)))
                     deriving (Eq,Show)
data TYPEDECLARATION_Attrs = TYPEDECLARATION_Attrs
    { tYPEDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data CONTEXTDECLARATION = CONTEXTDECLARATION CONTEXTDECLARATION_Attrs
                                             IDENTIFIER CONTEXTNAME
                        deriving (Eq,Show)
data CONTEXTDECLARATION_Attrs = CONTEXTDECLARATION_Attrs
    { cONTEXTDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data CONTEXTNAME = CONTEXTNAME CONTEXTNAME_Attrs IDENTIFIER
                               (Maybe ACTUALPARAMETERS)
                 deriving (Eq,Show)
data CONTEXTNAME_Attrs = CONTEXTNAME_Attrs
    { cONTEXTNAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ACTUALPARAMETERS = ACTUALPARAMETERS ACTUALPARAMETERS_Attrs
                                         (Maybe ACTUALTYPES) (Maybe ACTUALEXPRS)
                      deriving (Eq,Show)
data ACTUALPARAMETERS_Attrs = ACTUALPARAMETERS_Attrs
    { aCTUALPARAMETERSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ACTUALTYPES = ACTUALTYPES ACTUALTYPES_Attrs
                               [((OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE))]
                 deriving (Eq,Show)
data ACTUALTYPES_Attrs = ACTUALTYPES_Attrs
    { aCTUALTYPESPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ACTUALEXPRS = ACTUALEXPRS ACTUALEXPRS_Attrs
                               [((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))]
                 deriving (Eq,Show)
data ACTUALEXPRS_Attrs = ACTUALEXPRS_Attrs
    { aCTUALEXPRSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MODULEDECLARATION = MODULEDECLARATION MODULEDECLARATION_Attrs
                                           IDENTIFIER VARDECLS
                                           (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                       deriving (Eq,Show)
data MODULEDECLARATION_Attrs = MODULEDECLARATION_Attrs
    { mODULEDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data BASEMODULE = BASEMODULE BASEMODULE_Attrs (List1 BASEMODULE_)
                deriving (Eq,Show)
data BASEMODULE_Attrs = BASEMODULE_Attrs
    { bASEMODULEPLACE :: (Maybe String)
    , bASEMODULEPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data BASEMODULE_ = BASEMODULE_INPUTDECL INPUTDECL
                 | BASEMODULE_OUTPUTDECL OUTPUTDECL
                 | BASEMODULE_GLOBALDECL GLOBALDECL
                 | BASEMODULE_LOCALDECL LOCALDECL
                 | BASEMODULE_DEFDECL DEFDECL
                 | BASEMODULE_INITDECL INITDECL
                 | BASEMODULE_TRANSDECL TRANSDECL
                 deriving (Eq,Show)
data INPUTDECL = INPUTDECL INPUTDECL_Attrs (List1 VARDECL)
               deriving (Eq,Show)
data INPUTDECL_Attrs = INPUTDECL_Attrs
    { iNPUTDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data OUTPUTDECL = OUTPUTDECL OUTPUTDECL_Attrs (List1 VARDECL)
                deriving (Eq,Show)
data OUTPUTDECL_Attrs = OUTPUTDECL_Attrs
    { oUTPUTDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data GLOBALDECL = GLOBALDECL GLOBALDECL_Attrs (List1 VARDECL)
                deriving (Eq,Show)
data GLOBALDECL_Attrs = GLOBALDECL_Attrs
    { gLOBALDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LOCALDECL = LOCALDECL LOCALDECL_Attrs (List1 VARDECL)
               deriving (Eq,Show)
data LOCALDECL_Attrs = LOCALDECL_Attrs
    { lOCALDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data DEFDECL = DEFDECL DEFDECL_Attrs
                       (List1 ((OneOf2 SIMPLEDEFINITION FORALLDEFINITION)))
             deriving (Eq,Show)
data DEFDECL_Attrs = DEFDECL_Attrs
    { dEFDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data INITDECL = INITDECL INITDECL_Attrs
                         (List1 ((OneOf2 (OneOf2 SIMPLEDEFINITION FORALLDEFINITION) SOMECOMMANDS)))
              deriving (Eq,Show)
data INITDECL_Attrs = INITDECL_Attrs
    { iNITDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data TRANSDECL = TRANSDECL TRANSDECL_Attrs
                           (List1 ((OneOf2 (OneOf2 SIMPLEDEFINITION FORALLDEFINITION) SOMECOMMANDS)))
               deriving (Eq,Show)
data TRANSDECL_Attrs = TRANSDECL_Attrs
    { tRANSDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SIMPLEDEFINITION = SIMPLEDEFINITION SIMPLEDEFINITION_Attrs
                                         ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
                                         (OneOf2 RHSEXPRESSION RHSSELECTION)
                      deriving (Eq,Show)
data SIMPLEDEFINITION_Attrs = SIMPLEDEFINITION_Attrs
    { sIMPLEDEFINITIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data RHSEXPRESSION = RHSEXPRESSION RHSEXPRESSION_Attrs
                                   (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                   deriving (Eq,Show)
data RHSEXPRESSION_Attrs = RHSEXPRESSION_Attrs
    { rHSEXPRESSIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data RHSSELECTION = RHSSELECTION RHSSELECTION_Attrs
                                 (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                  deriving (Eq,Show)
data RHSSELECTION_Attrs = RHSSELECTION_Attrs
    { rHSSELECTIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data FORALLDEFINITION = FORALLDEFINITION FORALLDEFINITION_Attrs
                                         VARDECLS
                                         (List1 ((OneOf2 SIMPLEDEFINITION FORALLDEFINITION)))
                      deriving (Eq,Show)
data FORALLDEFINITION_Attrs = FORALLDEFINITION_Attrs
    { fORALLDEFINITIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LABELEDCOMMAND = LABELEDCOMMAND LABELEDCOMMAND_Attrs LABEL
                                     GUARDEDCOMMAND
                    deriving (Eq,Show)
data LABELEDCOMMAND_Attrs = LABELEDCOMMAND_Attrs
    { lABELEDCOMMANDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LABELEDELSECOMMAND = LABELEDELSECOMMAND LABELEDELSECOMMAND_Attrs
                                             LABEL ELSECOMMAND
                        deriving (Eq,Show)
data LABELEDELSECOMMAND_Attrs = LABELEDELSECOMMAND_Attrs
    { lABELEDELSECOMMANDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LABEL = LABEL LABEL_Attrs String
           deriving (Eq,Show)
data LABEL_Attrs = LABEL_Attrs
    { lABELPLACE :: (Maybe String)
    } deriving (Eq,Show)
data GUARDEDCOMMAND = GUARDEDCOMMAND GUARDEDCOMMAND_Attrs GUARD
                                     ASSIGNMENTS
                    deriving (Eq,Show)
data GUARDEDCOMMAND_Attrs = GUARDEDCOMMAND_Attrs
    { gUARDEDCOMMANDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data GUARD = GUARD GUARD_Attrs
                   (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
           deriving (Eq,Show)
data GUARD_Attrs = GUARD_Attrs
    { gUARDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ELSECOMMAND = ELSECOMMAND ELSECOMMAND_Attrs ASSIGNMENTS
                 deriving (Eq,Show)
data ELSECOMMAND_Attrs = ELSECOMMAND_Attrs
    { eLSECOMMANDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ASSIGNMENTS = ASSIGNMENTS ASSIGNMENTS_Attrs
                               (List1 SIMPLEDEFINITION)
                 deriving (Eq,Show)
data ASSIGNMENTS_Attrs = ASSIGNMENTS_Attrs
    { aSSIGNMENTSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SOMECOMMANDS = SOMECOMMANDS SOMECOMMANDS_Attrs
                                 (List1 ((OneOf3 GUARDEDCOMMAND LABELEDCOMMAND MULTICOMMAND)))
                                 (Maybe ((OneOf2 ELSECOMMAND LABELEDELSECOMMAND)))
                  deriving (Eq,Show)
data SOMECOMMANDS_Attrs = SOMECOMMANDS_Attrs
    { sOMECOMMANDSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MULTICOMMAND = MULTICOMMAND MULTICOMMAND_Attrs VARDECLS
                                 (OneOf3 GUARDEDCOMMAND LABELEDCOMMAND MULTICOMMAND)
                  deriving (Eq,Show)
data MULTICOMMAND_Attrs = MULTICOMMAND_Attrs
    { mULTICOMMANDPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SYNCHRONOUSCOMPOSITION = SYNCHRONOUSCOMPOSITION SYNCHRONOUSCOMPOSITION_Attrs
                                                     (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                                                     (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                            deriving (Eq,Show)
data SYNCHRONOUSCOMPOSITION_Attrs = SYNCHRONOUSCOMPOSITION_Attrs
    { sYNCHRONOUSCOMPOSITIONPLACE :: (Maybe String)
    , sYNCHRONOUSCOMPOSITIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data ASYNCHRONOUSCOMPOSITION = ASYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION_Attrs
                                                       (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                                                       (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                             deriving (Eq,Show)
data ASYNCHRONOUSCOMPOSITION_Attrs = ASYNCHRONOUSCOMPOSITION_Attrs
    { aSYNCHRONOUSCOMPOSITIONPLACE :: (Maybe String)
    , aSYNCHRONOUSCOMPOSITIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data MULTISYNCHRONOUS = MULTISYNCHRONOUS MULTISYNCHRONOUS_Attrs
                                         INDEXVARDECL
                                         (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                      deriving (Eq,Show)
data MULTISYNCHRONOUS_Attrs = MULTISYNCHRONOUS_Attrs
    { mULTISYNCHRONOUSPLACE :: (Maybe String)
    , mULTISYNCHRONOUSPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data MULTIASYNCHRONOUS = MULTIASYNCHRONOUS MULTIASYNCHRONOUS_Attrs
                                           INDEXVARDECL
                                           (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                       deriving (Eq,Show)
data MULTIASYNCHRONOUS_Attrs = MULTIASYNCHRONOUS_Attrs
    { mULTIASYNCHRONOUSPLACE :: (Maybe String)
    , mULTIASYNCHRONOUSPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data HIDING = HIDING HIDING_Attrs IDENTIFIERS
                     (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
            deriving (Eq,Show)
data HIDING_Attrs = HIDING_Attrs
    { hIDINGPLACE :: (Maybe String)
    , hIDINGPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data NEWOUTPUT = NEWOUTPUT NEWOUTPUT_Attrs IDENTIFIERS
                           (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
               deriving (Eq,Show)
data NEWOUTPUT_Attrs = NEWOUTPUT_Attrs
    { nEWOUTPUTPLACE :: (Maybe String)
    , nEWOUTPUTPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data RENAMING = RENAMING RENAMING_Attrs RENAMES
                         (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
              deriving (Eq,Show)
data RENAMING_Attrs = RENAMING_Attrs
    { rENAMINGPLACE :: (Maybe String)
    , rENAMINGPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data WITHMODULE = WITHMODULE WITHMODULE_Attrs NEWVARDECLS
                             (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                deriving (Eq,Show)
data WITHMODULE_Attrs = WITHMODULE_Attrs
    { wITHMODULEPLACE :: (Maybe String)
    , wITHMODULEPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data NEWVARDECLS = NEWVARDECLS NEWVARDECLS_Attrs
                               (List1 (OneOf3 INPUTDECL OUTPUTDECL GLOBALDECL))
                 deriving (Eq,Show)
data NEWVARDECLS_Attrs = NEWVARDECLS_Attrs
    { nEWVARDECLSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data RENAMES = RENAMES RENAMES_Attrs (List1 RENAME)
             deriving (Eq,Show)
data RENAMES_Attrs = RENAMES_Attrs
    { rENAMESPLACE :: (Maybe String)
    } deriving (Eq,Show)
data RENAME = RENAME RENAME_Attrs
                     ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
                     ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
            deriving (Eq,Show)
data RENAME_Attrs = RENAME_Attrs
    { rENAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MODULEINSTANCE = MODULEINSTANCE MODULEINSTANCE_Attrs
                                     (OneOf2 MODULENAME QUALIFIEDMODULENAME) MODULEACTUALS
                    deriving (Eq,Show)
data MODULEINSTANCE_Attrs = MODULEINSTANCE_Attrs
    { mODULEINSTANCEPLACE :: (Maybe String)
    , mODULEINSTANCEPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data MODULENAME = MODULENAME MODULENAME_Attrs String
                deriving (Eq,Show)
data MODULENAME_Attrs = MODULENAME_Attrs
    { mODULENAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data QUALIFIEDMODULENAME = QUALIFIEDMODULENAME QUALIFIEDMODULENAME_Attrs
                                               (IDENTIFIER,CONTEXTNAME)
                         deriving (Eq,Show)
data QUALIFIEDMODULENAME_Attrs = QUALIFIEDMODULENAME_Attrs
    { qUALIFIEDMODULENAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MODULEACTUALS = MODULEACTUALS MODULEACTUALS_Attrs
                                   [((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))]
                   deriving (Eq,Show)
data MODULEACTUALS_Attrs = MODULEACTUALS_Attrs
    { mODULEACTUALSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data OBSERVEMODULE = OBSERVEMODULE OBSERVEMODULE_Attrs
                                   (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                                   (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                   deriving (Eq,Show)
data OBSERVEMODULE_Attrs = OBSERVEMODULE_Attrs
    { oBSERVEMODULEPLACE :: (Maybe String)
    , oBSERVEMODULEPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data SCALARTYPE = SCALARTYPE SCALARTYPE_Attrs (List1 SCALARELEMENT)
                deriving (Eq,Show)
data SCALARTYPE_Attrs = SCALARTYPE_Attrs
    { sCALARTYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SCALARELEMENT = SCALARELEMENT SCALARELEMENT_Attrs String
                   deriving (Eq,Show)
data SCALARELEMENT_Attrs = SCALARELEMENT_Attrs
    { sCALARELEMENTPLACE :: (Maybe String)
    } deriving (Eq,Show)
data DATATYPE = DATATYPE DATATYPE_Attrs (List1 CONSTRUCTOR)
              deriving (Eq,Show)
data DATATYPE_Attrs = DATATYPE_Attrs
    { dATATYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data CONSTRUCTOR = CONSTRUCTOR CONSTRUCTOR_Attrs IDENTIFIER
                               [ACCESSOR]
                 deriving (Eq,Show)
data CONSTRUCTOR_Attrs = CONSTRUCTOR_Attrs
    { cONSTRUCTORPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ACCESSOR = ACCESSOR ACCESSOR_Attrs IDENTIFIER
                         (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
              deriving (Eq,Show)
data ACCESSOR_Attrs = ACCESSOR_Attrs
    { aCCESSORPLACE :: (Maybe String)
    } deriving (Eq,Show)
data TYPENAME = TYPENAME TYPENAME_Attrs String
              deriving (Eq,Show)
data TYPENAME_Attrs = TYPENAME_Attrs
    { tYPENAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data QUALIFIEDTYPENAME = QUALIFIEDTYPENAME QUALIFIEDTYPENAME_Attrs
                                           (IDENTIFIER,CONTEXTNAME)
                       deriving (Eq,Show)
data QUALIFIEDTYPENAME_Attrs = QUALIFIEDTYPENAME_Attrs
    { qUALIFIEDTYPENAMEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SUBRANGE = SUBRANGE SUBRANGE_Attrs
                         ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
                         ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
              deriving (Eq,Show)
data SUBRANGE_Attrs = SUBRANGE_Attrs
    { sUBRANGEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ARRAYTYPE = ARRAYTYPE ARRAYTYPE_Attrs
                           (OneOf2 TYPENAME SUBRANGE)
                           (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
               deriving (Eq,Show)
data ARRAYTYPE_Attrs = ARRAYTYPE_Attrs
    { aRRAYTYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data TUPLETYPE = TUPLETYPE TUPLETYPE_Attrs
                           (List1 ((OneOf2 (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE) VARDECL)))
               deriving (Eq,Show)
data TUPLETYPE_Attrs = TUPLETYPE_Attrs
    { tUPLETYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data RECORDTYPE = RECORDTYPE RECORDTYPE_Attrs
                             (List1 FIELDDECLARATION)
                deriving (Eq,Show)
data RECORDTYPE_Attrs = RECORDTYPE_Attrs
    { rECORDTYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data FIELDDECLARATION = FIELDDECLARATION FIELDDECLARATION_Attrs
                                         IDENTIFIER
                                         (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
                      deriving (Eq,Show)
data FIELDDECLARATION_Attrs = FIELDDECLARATION_Attrs
    { fIELDDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data FUNCTIONTYPE = FUNCTIONTYPE FUNCTIONTYPE_Attrs
                                 (OneOf2 (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE) VARDECL)
                                 (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
                  deriving (Eq,Show)
data FUNCTIONTYPE_Attrs = FUNCTIONTYPE_Attrs
    { fUNCTIONTYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SUBTYPE = SUBTYPE SUBTYPE_Attrs
                       (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
             deriving (Eq,Show)
data SUBTYPE_Attrs = SUBTYPE_Attrs
    { sUBTYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data STATETYPE = STATETYPE STATETYPE_Attrs
                           (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
               deriving (Eq,Show)
data STATETYPE_Attrs = STATETYPE_Attrs
    { sTATETYPEPLACE :: (Maybe String)
    } deriving (Eq,Show)
data NEXTOPERATOR = NEXTOPERATOR NEXTOPERATOR_Attrs NAMEEXPR
                  deriving (Eq,Show)
data NEXTOPERATOR_Attrs = NEXTOPERATOR_Attrs
    { nEXTOPERATORPLACE :: (Maybe String)
    , nEXTOPERATORPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data NAMEEXPR = NAMEEXPR NAMEEXPR_Attrs String
              deriving (Eq,Show)
data NAMEEXPR_Attrs = NAMEEXPR_Attrs
    { nAMEEXPRPLACE :: (Maybe String)
    , nAMEEXPRPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data QUALIFIEDNAMEEXPR = QUALIFIEDNAMEEXPR QUALIFIEDNAMEEXPR_Attrs
                                           (IDENTIFIER,CONTEXTNAME)
                       deriving (Eq,Show)
data QUALIFIEDNAMEEXPR_Attrs = QUALIFIEDNAMEEXPR_Attrs
    { qUALIFIEDNAMEEXPRPLACE :: (Maybe String)
    , qUALIFIEDNAMEEXPRPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data APPLICATION = APPLICATION APPLICATION_Attrs
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                 deriving (Eq,Show)
data APPLICATION_Attrs = APPLICATION_Attrs
    { aPPLICATIONPLACE :: (Maybe String)
    , aPPLICATIONINFIX :: (Defaultable APPLICATION_INFIX)
    , aPPLICATIONUNARY :: (Defaultable APPLICATION_UNARY)
    , aPPLICATIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data APPLICATION_INFIX = APPLICATION_INFIX_YES  |
                         APPLICATION_INFIX_NO
                       deriving (Eq,Show)
data APPLICATION_UNARY = APPLICATION_UNARY_YES  |
                         APPLICATION_UNARY_NO
                       deriving (Eq,Show)
data ARRAYSELECTION = ARRAYSELECTION ARRAYSELECTION_Attrs
                                     (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                                     (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                    deriving (Eq,Show)
data ARRAYSELECTION_Attrs = ARRAYSELECTION_Attrs
    { aRRAYSELECTIONPLACE :: (Maybe String)
    , aRRAYSELECTIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data RECORDSELECTION = RECORDSELECTION RECORDSELECTION_Attrs
                                       (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                                       IDENTIFIER
                     deriving (Eq,Show)
data RECORDSELECTION_Attrs = RECORDSELECTION_Attrs
    { rECORDSELECTIONPLACE :: (Maybe String)
    , rECORDSELECTIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data TUPLESELECTION = TUPLESELECTION TUPLESELECTION_Attrs
                                     (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                                     NUMERAL
                    deriving (Eq,Show)
data TUPLESELECTION_Attrs = TUPLESELECTION_Attrs
    { tUPLESELECTIONPLACE :: (Maybe String)
    , tUPLESELECTIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data RECORDLITERAL = RECORDLITERAL RECORDLITERAL_Attrs
                                   (List1 RECORDENTRY)
                   deriving (Eq,Show)
data RECORDLITERAL_Attrs = RECORDLITERAL_Attrs
    { rECORDLITERALPLACE :: (Maybe String)
    , rECORDLITERALPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data RECORDENTRY = RECORDENTRY RECORDENTRY_Attrs IDENTIFIER
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                 deriving (Eq,Show)
data RECORDENTRY_Attrs = RECORDENTRY_Attrs
    { rECORDENTRYPLACE :: (Maybe String)
    } deriving (Eq,Show)
data TUPLELITERAL = TUPLELITERAL TUPLELITERAL_Attrs
                                 (List1 ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)))
                  deriving (Eq,Show)
data TUPLELITERAL_Attrs = TUPLELITERAL_Attrs
    { tUPLELITERALPLACE :: (Maybe String)
    , tUPLELITERALPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data UPDATEEXPRESSION = UPDATEEXPRESSION UPDATEEXPRESSION_Attrs
                                         DEPTH
                                         (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                                         (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                      deriving (Eq,Show)
data UPDATEEXPRESSION_Attrs = UPDATEEXPRESSION_Attrs
    { uPDATEEXPRESSIONPLACE :: (Maybe String)
    , uPDATEEXPRESSIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
newtype DEPTH = DEPTH String 		deriving (Eq,Show)
data ARRAYLITERAL = ARRAYLITERAL ARRAYLITERAL_Attrs INDEXVARDECL
                                 (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                  deriving (Eq,Show)
data ARRAYLITERAL_Attrs = ARRAYLITERAL_Attrs
    { aRRAYLITERALPLACE :: (Maybe String)
    , aRRAYLITERALPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data INDEXVARDECL = INDEXVARDECL INDEXVARDECL_Attrs IDENTIFIER
                                 (OneOf2 TYPENAME SUBRANGE)
                  deriving (Eq,Show)
data INDEXVARDECL_Attrs = INDEXVARDECL_Attrs
    { iNDEXVARDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LAMBDAABSTRACTION = LAMBDAABSTRACTION LAMBDAABSTRACTION_Attrs
                                           VARDECLS
                                           (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                       deriving (Eq,Show)
data LAMBDAABSTRACTION_Attrs = LAMBDAABSTRACTION_Attrs
    { lAMBDAABSTRACTIONPLACE :: (Maybe String)
    , lAMBDAABSTRACTIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data QUANTIFIEDEXPRESSION = QUANTIFIEDEXPRESSION QUANTIFIEDEXPRESSION_Attrs
                                                 QUANTIFIER VARDECLS
                                                 (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                          deriving (Eq,Show)
data QUANTIFIEDEXPRESSION_Attrs = QUANTIFIEDEXPRESSION_Attrs
    { qUANTIFIEDEXPRESSIONPLACE :: (Maybe String)
    , qUANTIFIEDEXPRESSIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data QUANTIFIER = QUANTIFIER QUANTIFIER_Attrs String
                deriving (Eq,Show)
data QUANTIFIER_Attrs = QUANTIFIER_Attrs
    { qUANTIFIERPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LETEXPRESSION = LETEXPRESSION LETEXPRESSION_Attrs
                                   LETDECLARATIONS
                                   (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                   deriving (Eq,Show)
data LETEXPRESSION_Attrs = LETEXPRESSION_Attrs
    { lETEXPRESSIONPLACE :: (Maybe String)
    , lETEXPRESSIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data LETDECLARATIONS = LETDECLARATIONS LETDECLARATIONS_Attrs
                                       (List1 (LETDECLARATION))
                     deriving (Eq,Show)
data LETDECLARATIONS_Attrs = LETDECLARATIONS_Attrs
    { lETDECLARATIONSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data LETDECLARATION = LETDECLARATION LETDECLARATION_Attrs
                                     IDENTIFIER
                                     (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
                                     (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                    deriving (Eq,Show)
data LETDECLARATION_Attrs = LETDECLARATION_Attrs
    { lETDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data SETPREDEXPRESSION = SETPREDEXPRESSION SETPREDEXPRESSION_Attrs
                                           IDENTIFIER
                                           (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
                                           (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                       deriving (Eq,Show)
data SETPREDEXPRESSION_Attrs = SETPREDEXPRESSION_Attrs
    { sETPREDEXPRESSIONPLACE :: (Maybe String)
    , sETPREDEXPRESSIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data SETLISTEXPRESSION = SETLISTEXPRESSION SETLISTEXPRESSION_Attrs
                                           (List1 ((OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)))
                       deriving (Eq,Show)
data SETLISTEXPRESSION_Attrs = SETLISTEXPRESSION_Attrs
    { sETLISTEXPRESSIONPLACE :: (Maybe String)
    , sETLISTEXPRESSIONPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data CONDITIONAL = CONDITIONAL CONDITIONAL_Attrs
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                               (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                 deriving (Eq,Show)
data CONDITIONAL_Attrs = CONDITIONAL_Attrs
    { cONDITIONALPLACE :: (Maybe String)
    , cONDITIONALELSIF :: (Defaultable CONDITIONAL_ELSIF)
    , cONDITIONALPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data CONDITIONAL_ELSIF = CONDITIONAL_ELSIF_YES  |
                         CONDITIONAL_ELSIF_NO
                       deriving (Eq,Show)
data MODINIT = MODINIT MODINIT_Attrs
                       (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
             deriving (Eq,Show)
data MODINIT_Attrs = MODINIT_Attrs
    { mODINITPLACE :: (Maybe String)
    , mODINITPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data MODTRANS = MODTRANS MODTRANS_Attrs
                         (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
              deriving (Eq,Show)
data MODTRANS_Attrs = MODTRANS_Attrs
    { mODTRANSPLACE :: (Maybe String)
    , mODTRANSPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data NUMERAL = NUMERAL NUMERAL_Attrs String
             deriving (Eq,Show)
data NUMERAL_Attrs = NUMERAL_Attrs
    { nUMERALPLACE :: (Maybe String)
    , nUMERALPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data STRINGEXPR = STRINGEXPR STRINGEXPR_Attrs String
                deriving (Eq,Show)
data STRINGEXPR_Attrs = STRINGEXPR_Attrs
    { sTRINGEXPRPLACE :: (Maybe String)
    , sTRINGEXPRPARENS :: (Defaultable String)
    } deriving (Eq,Show)
data VARDECL = VARDECL VARDECL_Attrs IDENTIFIER
                       (OneOf9 TYPENAME QUALIFIEDTYPENAME SUBRANGE ARRAYTYPE TUPLETYPE FUNCTIONTYPE RECORDTYPE SUBTYPE STATETYPE)
             deriving (Eq,Show)
data VARDECL_Attrs = VARDECL_Attrs
    { vARDECLPLACE :: (Maybe String)
    , vARDECLCHAIN :: (Defaultable VARDECL_CHAIN)
    } deriving (Eq,Show)
data VARDECL_CHAIN = VARDECL_CHAIN_YES  |  VARDECL_CHAIN_NO
                   deriving (Eq,Show)
data TYPEDECL = TYPEDECL TYPEDECL_Attrs IDENTIFIER
              deriving (Eq,Show)
data TYPEDECL_Attrs = TYPEDECL_Attrs
    { tYPEDECLPLACE :: (Maybe String)
    } deriving (Eq,Show)
data IDENTIFIERS = IDENTIFIERS IDENTIFIERS_Attrs (List1 IDENTIFIER)
                 deriving (Eq,Show)
data IDENTIFIERS_Attrs = IDENTIFIERS_Attrs
    { iDENTIFIERSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data IDENTIFIER = IDENTIFIER IDENTIFIER_Attrs String
                deriving (Eq,Show)
data IDENTIFIER_Attrs = IDENTIFIER_Attrs
    { iDENTIFIERPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ASSERTIONDECLARATION = ASSERTIONDECLARATION ASSERTIONDECLARATION_Attrs
                                                 IDENTIFIER ASSERTIONFORM
                                                 (OneOf4 ASSERTIONPROPOSITION QUANTIFIEDASSERTION (OneOf2 MODULEMODELS MODULEIMPLEMENTS) (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
                          deriving (Eq,Show)
data ASSERTIONDECLARATION_Attrs = ASSERTIONDECLARATION_Attrs
    { aSSERTIONDECLARATIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ASSERTIONFORM = ASSERTIONFORM ASSERTIONFORM_Attrs String
                   deriving (Eq,Show)
data ASSERTIONFORM_Attrs = ASSERTIONFORM_Attrs
    { aSSERTIONFORMPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ASSERTIONPROPOSITION = ASSERTIONPROPOSITION ASSERTIONPROPOSITION_Attrs
                                                 ASSERTIONOPERATOR
                                                 ((List1 ((OneOf4 ASSERTIONPROPOSITION QUANTIFIEDASSERTION (OneOf2 MODULEMODELS MODULEIMPLEMENTS) (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)))))
                          deriving (Eq,Show)
data ASSERTIONPROPOSITION_Attrs = ASSERTIONPROPOSITION_Attrs
    { aSSERTIONPROPOSITIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data ASSERTIONOPERATOR = ASSERTIONOPERATOR ASSERTIONOPERATOR_Attrs
                                           String
                       deriving (Eq,Show)
data ASSERTIONOPERATOR_Attrs = ASSERTIONOPERATOR_Attrs
    { aSSERTIONOPERATORPLACE :: (Maybe String)
    } deriving (Eq,Show)
data QUANTIFIEDASSERTION = QUANTIFIEDASSERTION QUANTIFIEDASSERTION_Attrs
                                               QUANTIFIER VARDECLS
                                               (OneOf4 ASSERTIONPROPOSITION QUANTIFIEDASSERTION (OneOf2 MODULEMODELS MODULEIMPLEMENTS) (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS))
                         deriving (Eq,Show)
data QUANTIFIEDASSERTION_Attrs = QUANTIFIEDASSERTION_Attrs
    { qUANTIFIEDASSERTIONPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MODULEMODELS = MODULEMODELS MODULEMODELS_Attrs
                                 (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                                 (OneOf20 NAMEEXPR QUALIFIEDNAMEEXPR NEXTOPERATOR NUMERAL STRINGEXPR APPLICATION ARRAYSELECTION RECORDSELECTION TUPLESELECTION UPDATEEXPRESSION LAMBDAABSTRACTION QUANTIFIEDEXPRESSION LETEXPRESSION (OneOf2 SETLISTEXPRESSION SETPREDEXPRESSION) ARRAYLITERAL RECORDLITERAL TUPLELITERAL CONDITIONAL MODINIT MODTRANS)
                  deriving (Eq,Show)
data MODULEMODELS_Attrs = MODULEMODELS_Attrs
    { mODULEMODELSPLACE :: (Maybe String)
    } deriving (Eq,Show)
data MODULEIMPLEMENTS = MODULEIMPLEMENTS MODULEIMPLEMENTS_Attrs
                                         (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                                         (OneOf11 BASEMODULE SYNCHRONOUSCOMPOSITION ASYNCHRONOUSCOMPOSITION MULTISYNCHRONOUS MULTIASYNCHRONOUS HIDING NEWOUTPUT RENAMING MODULEINSTANCE OBSERVEMODULE WITHMODULE)
                      deriving (Eq,Show)
data MODULEIMPLEMENTS_Attrs = MODULEIMPLEMENTS_Attrs
    { mODULEIMPLEMENTSPLACE :: (Maybe String)
    } deriving (Eq,Show)


{-Instance decls-}

instance HTypeable CONTEXT where
    toHType x = Defined "CONTEXT" [] []
instance XmlContent CONTEXT where
    toContents (CONTEXT as a b c) =
        [CElem (Elem "CONTEXT" (toAttrs as) (toContents a ++ toContents b
                                             ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONTEXT"]
        ; interior e $ return (CONTEXT (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <CONTEXT>, "++)
instance XmlAttributes CONTEXT_Attrs where
    fromAttrs as =
        CONTEXT_Attrs
          { cONTEXTPLACE = possibleA fromAttrToStr "PLACE" as
          , cONTEXTLOGIC = defaultA fromAttrToTyp CONTEXT_LOGIC_NO "LOGIC" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONTEXTPLACE v)
        , defaultToAttr toAttrFrTyp "LOGIC" (cONTEXTLOGIC v)
        ]

instance XmlAttrType CONTEXT_LOGIC where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just CONTEXT_LOGIC_YES
            translate "NO" = Just CONTEXT_LOGIC_NO
            translate _ = Nothing
    toAttrFrTyp n CONTEXT_LOGIC_YES = Just (n, str2attr "YES")
    toAttrFrTyp n CONTEXT_LOGIC_NO = Just (n, str2attr "NO")

instance HTypeable PARAMETERS where
    toHType x = Defined "PARAMETERS" [] []
instance XmlContent PARAMETERS where
    toContents (PARAMETERS as a b) =
        [CElem (Elem "PARAMETERS" (toAttrs as) (maybe [] toContents a ++
                                                maybe [] toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["PARAMETERS"]
        ; interior e $ return (PARAMETERS (fromAttrs as))
                       `apply` optional parseContents `apply` optional parseContents
        } `adjustErr` ("in <PARAMETERS>, "++)
instance XmlAttributes PARAMETERS_Attrs where
    fromAttrs as =
        PARAMETERS_Attrs
          { pARAMETERSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (pARAMETERSPLACE v)
        ]

instance HTypeable TYPEDECLS where
    toHType x = Defined "TYPEDECLS" [] []
instance XmlContent TYPEDECLS where
    toContents (TYPEDECLS as a) =
        [CElem (Elem "TYPEDECLS" (toAttrs as) (concatMap toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TYPEDECLS"]
        ; interior e $ return (TYPEDECLS (fromAttrs as))
                       `apply` many parseContents
        } `adjustErr` ("in <TYPEDECLS>, "++)
instance XmlAttributes TYPEDECLS_Attrs where
    fromAttrs as =
        TYPEDECLS_Attrs
          { tYPEDECLSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tYPEDECLSPLACE v)
        ]

instance HTypeable VARDECLS where
    toHType x = Defined "VARDECLS" [] []
instance XmlContent VARDECLS where
    toContents (VARDECLS as a) =
        [CElem (Elem "VARDECLS" (toAttrs as) (concatMap toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["VARDECLS"]
        ; interior e $ return (VARDECLS (fromAttrs as))
                       `apply` many parseContents
        } `adjustErr` ("in <VARDECLS>, "++)
instance XmlAttributes VARDECLS_Attrs where
    fromAttrs as =
        VARDECLS_Attrs
          { vARDECLSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (vARDECLSPLACE v)
        ]

instance HTypeable CONTEXTBODY where
    toHType x = Defined "CONTEXTBODY" [] []
instance XmlContent CONTEXTBODY where
    toContents (CONTEXTBODY as a) =
        [CElem (Elem "CONTEXTBODY" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONTEXTBODY"]
        ; interior e $ return (CONTEXTBODY (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <CONTEXTBODY>, "++)
instance XmlAttributes CONTEXTBODY_Attrs where
    fromAttrs as =
        CONTEXTBODY_Attrs
          { cONTEXTBODYPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONTEXTBODYPLACE v)
        ]

instance HTypeable CONTEXTBODY_ where
    toHType x = Defined "CONTEXTBODY" [] []
instance XmlContent CONTEXTBODY_ where
    toContents (CONTEXTBODY_CONSTANTDECLARATION a) = toContents a
    toContents (CONTEXTBODY_TYPEDECLARATION a) = toContents a
    toContents (CONTEXTBODY_ASSERTIONDECLARATION a) = toContents a
    toContents (CONTEXTBODY_CONTEXTDECLARATION a) = toContents a
    toContents (CONTEXTBODY_MODULEDECLARATION a) = toContents a
    parseContents = oneOf
        [ return (CONTEXTBODY_CONSTANTDECLARATION) `apply` parseContents
        , return (CONTEXTBODY_TYPEDECLARATION) `apply` parseContents
        , return (CONTEXTBODY_ASSERTIONDECLARATION) `apply` parseContents
        , return (CONTEXTBODY_CONTEXTDECLARATION) `apply` parseContents
        , return (CONTEXTBODY_MODULEDECLARATION) `apply` parseContents
        ] `adjustErr` ("in <CONTEXTBODY>, "++)

instance HTypeable CONSTANTDECLARATION where
    toHType x = Defined "CONSTANTDECLARATION" [] []
instance XmlContent CONSTANTDECLARATION where
    toContents (CONSTANTDECLARATION as a b c) =
        [CElem (Elem "CONSTANTDECLARATION" (toAttrs as) (toContents a ++
                                                         toContents b ++ maybe [] toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONSTANTDECLARATION"]
        ; interior e $ return (CONSTANTDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
                       `apply` optional parseContents
        } `adjustErr` ("in <CONSTANTDECLARATION>, "++)
instance XmlAttributes CONSTANTDECLARATION_Attrs where
    fromAttrs as =
        CONSTANTDECLARATION_Attrs
          { cONSTANTDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          , cONSTANTDECLARATIONFUNCTIONAL = defaultA fromAttrToTyp CONSTANTDECLARATION_FUNCTIONAL_NO "FUNCTIONAL" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONSTANTDECLARATIONPLACE v)
        , defaultToAttr toAttrFrTyp "FUNCTIONAL" (cONSTANTDECLARATIONFUNCTIONAL v)
        ]

instance XmlAttrType CONSTANTDECLARATION_FUNCTIONAL where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just CONSTANTDECLARATION_FUNCTIONAL_YES
            translate "NO" = Just CONSTANTDECLARATION_FUNCTIONAL_NO
            translate _ = Nothing
    toAttrFrTyp n CONSTANTDECLARATION_FUNCTIONAL_YES = Just (n, str2attr "YES")
    toAttrFrTyp n CONSTANTDECLARATION_FUNCTIONAL_NO = Just (n, str2attr "NO")

instance HTypeable TYPEDECLARATION where
    toHType x = Defined "TYPEDECLARATION" [] []
instance XmlContent TYPEDECLARATION where
    toContents (TYPEDECLARATION as a b) =
        [CElem (Elem "TYPEDECLARATION" (toAttrs as) (toContents a ++
                                                     maybe [] toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TYPEDECLARATION"]
        ; interior e $ return (TYPEDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` optional parseContents
        } `adjustErr` ("in <TYPEDECLARATION>, "++)
instance XmlAttributes TYPEDECLARATION_Attrs where
    fromAttrs as =
        TYPEDECLARATION_Attrs
          { tYPEDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tYPEDECLARATIONPLACE v)
        ]

instance HTypeable CONTEXTDECLARATION where
    toHType x = Defined "CONTEXTDECLARATION" [] []
instance XmlContent CONTEXTDECLARATION where
    toContents (CONTEXTDECLARATION as a b) =
        [CElem (Elem "CONTEXTDECLARATION" (toAttrs as) (toContents a ++
                                                        toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONTEXTDECLARATION"]
        ; interior e $ return (CONTEXTDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <CONTEXTDECLARATION>, "++)
instance XmlAttributes CONTEXTDECLARATION_Attrs where
    fromAttrs as =
        CONTEXTDECLARATION_Attrs
          { cONTEXTDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONTEXTDECLARATIONPLACE v)
        ]

instance HTypeable CONTEXTNAME where
    toHType x = Defined "CONTEXTNAME" [] []
instance XmlContent CONTEXTNAME where
    toContents (CONTEXTNAME as a b) =
        [CElem (Elem "CONTEXTNAME" (toAttrs as) (toContents a ++
                                                 maybe [] toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONTEXTNAME"]
        ; interior e $ return (CONTEXTNAME (fromAttrs as))
                       `apply` parseContents `apply` optional parseContents
        } `adjustErr` ("in <CONTEXTNAME>, "++)
instance XmlAttributes CONTEXTNAME_Attrs where
    fromAttrs as =
        CONTEXTNAME_Attrs
          { cONTEXTNAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONTEXTNAMEPLACE v)
        ]

instance HTypeable ACTUALPARAMETERS where
    toHType x = Defined "ACTUALPARAMETERS" [] []
instance XmlContent ACTUALPARAMETERS where
    toContents (ACTUALPARAMETERS as a b) =
        [CElem (Elem "ACTUALPARAMETERS" (toAttrs as) (maybe [] toContents a
                                                      ++ maybe [] toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ACTUALPARAMETERS"]
        ; interior e $ return (ACTUALPARAMETERS (fromAttrs as))
                       `apply` optional parseContents `apply` optional parseContents
        } `adjustErr` ("in <ACTUALPARAMETERS>, "++)
instance XmlAttributes ACTUALPARAMETERS_Attrs where
    fromAttrs as =
        ACTUALPARAMETERS_Attrs
          { aCTUALPARAMETERSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aCTUALPARAMETERSPLACE v)
        ]

instance HTypeable ACTUALTYPES where
    toHType x = Defined "ACTUALTYPES" [] []
instance XmlContent ACTUALTYPES where
    toContents (ACTUALTYPES as a) =
        [CElem (Elem "ACTUALTYPES" (toAttrs as) (concatMap toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ACTUALTYPES"]
        ; interior e $ return (ACTUALTYPES (fromAttrs as))
                       `apply` many parseContents
        } `adjustErr` ("in <ACTUALTYPES>, "++)
instance XmlAttributes ACTUALTYPES_Attrs where
    fromAttrs as =
        ACTUALTYPES_Attrs
          { aCTUALTYPESPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aCTUALTYPESPLACE v)
        ]

instance HTypeable ACTUALEXPRS where
    toHType x = Defined "ACTUALEXPRS" [] []
instance XmlContent ACTUALEXPRS where
    toContents (ACTUALEXPRS as a) =
        [CElem (Elem "ACTUALEXPRS" (toAttrs as) (concatMap toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ACTUALEXPRS"]
        ; interior e $ return (ACTUALEXPRS (fromAttrs as))
                       `apply` many parseContents
        } `adjustErr` ("in <ACTUALEXPRS>, "++)
instance XmlAttributes ACTUALEXPRS_Attrs where
    fromAttrs as =
        ACTUALEXPRS_Attrs
          { aCTUALEXPRSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aCTUALEXPRSPLACE v)
        ]

instance HTypeable MODULEDECLARATION where
    toHType x = Defined "MODULEDECLARATION" [] []
instance XmlContent MODULEDECLARATION where
    toContents (MODULEDECLARATION as a b c) =
        [CElem (Elem "MODULEDECLARATION" (toAttrs as) (toContents a ++
                                                       toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULEDECLARATION"]
        ; interior e $ return (MODULEDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MODULEDECLARATION>, "++)
instance XmlAttributes MODULEDECLARATION_Attrs where
    fromAttrs as =
        MODULEDECLARATION_Attrs
          { mODULEDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULEDECLARATIONPLACE v)
        ]

instance HTypeable BASEMODULE where
    toHType x = Defined "BASEMODULE" [] []
instance XmlContent BASEMODULE where
    toContents (BASEMODULE as a) =
        [CElem (Elem "BASEMODULE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["BASEMODULE"]
        ; interior e $ return (BASEMODULE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <BASEMODULE>, "++)
instance XmlAttributes BASEMODULE_Attrs where
    fromAttrs as =
        BASEMODULE_Attrs
          { bASEMODULEPLACE = possibleA fromAttrToStr "PLACE" as
          , bASEMODULEPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (bASEMODULEPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (bASEMODULEPARENS v)
        ]

instance HTypeable BASEMODULE_ where
    toHType x = Defined "BASEMODULE" [] []
instance XmlContent BASEMODULE_ where
    toContents (BASEMODULE_INPUTDECL a) = toContents a
    toContents (BASEMODULE_OUTPUTDECL a) = toContents a
    toContents (BASEMODULE_GLOBALDECL a) = toContents a
    toContents (BASEMODULE_LOCALDECL a) = toContents a
    toContents (BASEMODULE_DEFDECL a) = toContents a
    toContents (BASEMODULE_INITDECL a) = toContents a
    toContents (BASEMODULE_TRANSDECL a) = toContents a
    parseContents = oneOf
        [ return (BASEMODULE_INPUTDECL) `apply` parseContents
        , return (BASEMODULE_OUTPUTDECL) `apply` parseContents
        , return (BASEMODULE_GLOBALDECL) `apply` parseContents
        , return (BASEMODULE_LOCALDECL) `apply` parseContents
        , return (BASEMODULE_DEFDECL) `apply` parseContents
        , return (BASEMODULE_INITDECL) `apply` parseContents
        , return (BASEMODULE_TRANSDECL) `apply` parseContents
        ] `adjustErr` ("in <BASEMODULE>, "++)

instance HTypeable INPUTDECL where
    toHType x = Defined "INPUTDECL" [] []
instance XmlContent INPUTDECL where
    toContents (INPUTDECL as a) =
        [CElem (Elem "INPUTDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["INPUTDECL"]
        ; interior e $ return (INPUTDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <INPUTDECL>, "++)
instance XmlAttributes INPUTDECL_Attrs where
    fromAttrs as =
        INPUTDECL_Attrs
          { iNPUTDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (iNPUTDECLPLACE v)
        ]

instance HTypeable OUTPUTDECL where
    toHType x = Defined "OUTPUTDECL" [] []
instance XmlContent OUTPUTDECL where
    toContents (OUTPUTDECL as a) =
        [CElem (Elem "OUTPUTDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["OUTPUTDECL"]
        ; interior e $ return (OUTPUTDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <OUTPUTDECL>, "++)
instance XmlAttributes OUTPUTDECL_Attrs where
    fromAttrs as =
        OUTPUTDECL_Attrs
          { oUTPUTDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (oUTPUTDECLPLACE v)
        ]

instance HTypeable GLOBALDECL where
    toHType x = Defined "GLOBALDECL" [] []
instance XmlContent GLOBALDECL where
    toContents (GLOBALDECL as a) =
        [CElem (Elem "GLOBALDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["GLOBALDECL"]
        ; interior e $ return (GLOBALDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <GLOBALDECL>, "++)
instance XmlAttributes GLOBALDECL_Attrs where
    fromAttrs as =
        GLOBALDECL_Attrs
          { gLOBALDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (gLOBALDECLPLACE v)
        ]

instance HTypeable LOCALDECL where
    toHType x = Defined "LOCALDECL" [] []
instance XmlContent LOCALDECL where
    toContents (LOCALDECL as a) =
        [CElem (Elem "LOCALDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LOCALDECL"]
        ; interior e $ return (LOCALDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <LOCALDECL>, "++)
instance XmlAttributes LOCALDECL_Attrs where
    fromAttrs as =
        LOCALDECL_Attrs
          { lOCALDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lOCALDECLPLACE v)
        ]

instance HTypeable DEFDECL where
    toHType x = Defined "DEFDECL" [] []
instance XmlContent DEFDECL where
    toContents (DEFDECL as a) =
        [CElem (Elem "DEFDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["DEFDECL"]
        ; interior e $ return (DEFDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <DEFDECL>, "++)
instance XmlAttributes DEFDECL_Attrs where
    fromAttrs as =
        DEFDECL_Attrs
          { dEFDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (dEFDECLPLACE v)
        ]

instance HTypeable INITDECL where
    toHType x = Defined "INITDECL" [] []
instance XmlContent INITDECL where
    toContents (INITDECL as a) =
        [CElem (Elem "INITDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["INITDECL"]
        ; interior e $ return (INITDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <INITDECL>, "++)
instance XmlAttributes INITDECL_Attrs where
    fromAttrs as =
        INITDECL_Attrs
          { iNITDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (iNITDECLPLACE v)
        ]

instance HTypeable TRANSDECL where
    toHType x = Defined "TRANSDECL" [] []
instance XmlContent TRANSDECL where
    toContents (TRANSDECL as a) =
        [CElem (Elem "TRANSDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TRANSDECL"]
        ; interior e $ return (TRANSDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <TRANSDECL>, "++)
instance XmlAttributes TRANSDECL_Attrs where
    fromAttrs as =
        TRANSDECL_Attrs
          { tRANSDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tRANSDECLPLACE v)
        ]

instance HTypeable SIMPLEDEFINITION where
    toHType x = Defined "SIMPLEDEFINITION" [] []
instance XmlContent SIMPLEDEFINITION where
    toContents (SIMPLEDEFINITION as a b) =
        [CElem (Elem "SIMPLEDEFINITION" (toAttrs as) (toContents a ++
                                                      toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SIMPLEDEFINITION"]
        ; interior e $ return (SIMPLEDEFINITION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <SIMPLEDEFINITION>, "++)
instance XmlAttributes SIMPLEDEFINITION_Attrs where
    fromAttrs as =
        SIMPLEDEFINITION_Attrs
          { sIMPLEDEFINITIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sIMPLEDEFINITIONPLACE v)
        ]

instance HTypeable RHSEXPRESSION where
    toHType x = Defined "RHSEXPRESSION" [] []
instance XmlContent RHSEXPRESSION where
    toContents (RHSEXPRESSION as a) =
        [CElem (Elem "RHSEXPRESSION" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RHSEXPRESSION"]
        ; interior e $ return (RHSEXPRESSION (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <RHSEXPRESSION>, "++)
instance XmlAttributes RHSEXPRESSION_Attrs where
    fromAttrs as =
        RHSEXPRESSION_Attrs
          { rHSEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rHSEXPRESSIONPLACE v)
        ]

instance HTypeable RHSSELECTION where
    toHType x = Defined "RHSSELECTION" [] []
instance XmlContent RHSSELECTION where
    toContents (RHSSELECTION as a) =
        [CElem (Elem "RHSSELECTION" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RHSSELECTION"]
        ; interior e $ return (RHSSELECTION (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <RHSSELECTION>, "++)
instance XmlAttributes RHSSELECTION_Attrs where
    fromAttrs as =
        RHSSELECTION_Attrs
          { rHSSELECTIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rHSSELECTIONPLACE v)
        ]

instance HTypeable FORALLDEFINITION where
    toHType x = Defined "FORALLDEFINITION" [] []
instance XmlContent FORALLDEFINITION where
    toContents (FORALLDEFINITION as a b) =
        [CElem (Elem "FORALLDEFINITION" (toAttrs as) (toContents a ++
                                                      toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["FORALLDEFINITION"]
        ; interior e $ return (FORALLDEFINITION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <FORALLDEFINITION>, "++)
instance XmlAttributes FORALLDEFINITION_Attrs where
    fromAttrs as =
        FORALLDEFINITION_Attrs
          { fORALLDEFINITIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (fORALLDEFINITIONPLACE v)
        ]

instance HTypeable LABELEDCOMMAND where
    toHType x = Defined "LABELEDCOMMAND" [] []
instance XmlContent LABELEDCOMMAND where
    toContents (LABELEDCOMMAND as a b) =
        [CElem (Elem "LABELEDCOMMAND" (toAttrs as) (toContents a ++
                                                    toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LABELEDCOMMAND"]
        ; interior e $ return (LABELEDCOMMAND (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <LABELEDCOMMAND>, "++)
instance XmlAttributes LABELEDCOMMAND_Attrs where
    fromAttrs as =
        LABELEDCOMMAND_Attrs
          { lABELEDCOMMANDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lABELEDCOMMANDPLACE v)
        ]

instance HTypeable LABELEDELSECOMMAND where
    toHType x = Defined "LABELEDELSECOMMAND" [] []
instance XmlContent LABELEDELSECOMMAND where
    toContents (LABELEDELSECOMMAND as a b) =
        [CElem (Elem "LABELEDELSECOMMAND" (toAttrs as) (toContents a ++
                                                        toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LABELEDELSECOMMAND"]
        ; interior e $ return (LABELEDELSECOMMAND (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <LABELEDELSECOMMAND>, "++)
instance XmlAttributes LABELEDELSECOMMAND_Attrs where
    fromAttrs as =
        LABELEDELSECOMMAND_Attrs
          { lABELEDELSECOMMANDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lABELEDELSECOMMANDPLACE v)
        ]

instance HTypeable LABEL where
    toHType x = Defined "LABEL" [] []
instance XmlContent LABEL where
    toContents (LABEL as a) =
        [CElem (Elem "LABEL" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LABEL"]
        ; interior e $ return (LABEL (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <LABEL>, "++)
instance XmlAttributes LABEL_Attrs where
    fromAttrs as =
        LABEL_Attrs
          { lABELPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lABELPLACE v)
        ]

instance HTypeable GUARDEDCOMMAND where
    toHType x = Defined "GUARDEDCOMMAND" [] []
instance XmlContent GUARDEDCOMMAND where
    toContents (GUARDEDCOMMAND as a b) =
        [CElem (Elem "GUARDEDCOMMAND" (toAttrs as) (toContents a ++
                                                    toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["GUARDEDCOMMAND"]
        ; interior e $ return (GUARDEDCOMMAND (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <GUARDEDCOMMAND>, "++)
instance XmlAttributes GUARDEDCOMMAND_Attrs where
    fromAttrs as =
        GUARDEDCOMMAND_Attrs
          { gUARDEDCOMMANDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (gUARDEDCOMMANDPLACE v)
        ]

instance HTypeable GUARD where
    toHType x = Defined "GUARD" [] []
instance XmlContent GUARD where
    toContents (GUARD as a) =
        [CElem (Elem "GUARD" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["GUARD"]
        ; interior e $ return (GUARD (fromAttrs as)) `apply` parseContents
        } `adjustErr` ("in <GUARD>, "++)
instance XmlAttributes GUARD_Attrs where
    fromAttrs as =
        GUARD_Attrs
          { gUARDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (gUARDPLACE v)
        ]

instance HTypeable ELSECOMMAND where
    toHType x = Defined "ELSECOMMAND" [] []
instance XmlContent ELSECOMMAND where
    toContents (ELSECOMMAND as a) =
        [CElem (Elem "ELSECOMMAND" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ELSECOMMAND"]
        ; interior e $ return (ELSECOMMAND (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <ELSECOMMAND>, "++)
instance XmlAttributes ELSECOMMAND_Attrs where
    fromAttrs as =
        ELSECOMMAND_Attrs
          { eLSECOMMANDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (eLSECOMMANDPLACE v)
        ]

instance HTypeable ASSIGNMENTS where
    toHType x = Defined "ASSIGNMENTS" [] []
instance XmlContent ASSIGNMENTS where
    toContents (ASSIGNMENTS as a) =
        [CElem (Elem "ASSIGNMENTS" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASSIGNMENTS"]
        ; interior e $ return (ASSIGNMENTS (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <ASSIGNMENTS>, "++)
instance XmlAttributes ASSIGNMENTS_Attrs where
    fromAttrs as =
        ASSIGNMENTS_Attrs
          { aSSIGNMENTSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSSIGNMENTSPLACE v)
        ]

instance HTypeable SOMECOMMANDS where
    toHType x = Defined "SOMECOMMANDS" [] []
instance XmlContent SOMECOMMANDS where
    toContents (SOMECOMMANDS as a b) =
        [CElem (Elem "SOMECOMMANDS" (toAttrs as) (toContents a ++
                                                  maybe [] toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SOMECOMMANDS"]
        ; interior e $ return (SOMECOMMANDS (fromAttrs as))
                       `apply` parseContents `apply` optional parseContents
        } `adjustErr` ("in <SOMECOMMANDS>, "++)
instance XmlAttributes SOMECOMMANDS_Attrs where
    fromAttrs as =
        SOMECOMMANDS_Attrs
          { sOMECOMMANDSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sOMECOMMANDSPLACE v)
        ]

instance HTypeable MULTICOMMAND where
    toHType x = Defined "MULTICOMMAND" [] []
instance XmlContent MULTICOMMAND where
    toContents (MULTICOMMAND as a b) =
        [CElem (Elem "MULTICOMMAND" (toAttrs as) (toContents a ++
                                                  toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MULTICOMMAND"]
        ; interior e $ return (MULTICOMMAND (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MULTICOMMAND>, "++)
instance XmlAttributes MULTICOMMAND_Attrs where
    fromAttrs as =
        MULTICOMMAND_Attrs
          { mULTICOMMANDPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mULTICOMMANDPLACE v)
        ]

instance HTypeable SYNCHRONOUSCOMPOSITION where
    toHType x = Defined "SYNCHRONOUSCOMPOSITION" [] []
instance XmlContent SYNCHRONOUSCOMPOSITION where
    toContents (SYNCHRONOUSCOMPOSITION as a b) =
        [CElem (Elem "SYNCHRONOUSCOMPOSITION" (toAttrs as) (toContents a ++
                                                            toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SYNCHRONOUSCOMPOSITION"]
        ; interior e $ return (SYNCHRONOUSCOMPOSITION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <SYNCHRONOUSCOMPOSITION>, "++)
instance XmlAttributes SYNCHRONOUSCOMPOSITION_Attrs where
    fromAttrs as =
        SYNCHRONOUSCOMPOSITION_Attrs
          { sYNCHRONOUSCOMPOSITIONPLACE = possibleA fromAttrToStr "PLACE" as
          , sYNCHRONOUSCOMPOSITIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sYNCHRONOUSCOMPOSITIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (sYNCHRONOUSCOMPOSITIONPARENS v)
        ]

instance HTypeable ASYNCHRONOUSCOMPOSITION where
    toHType x = Defined "ASYNCHRONOUSCOMPOSITION" [] []
instance XmlContent ASYNCHRONOUSCOMPOSITION where
    toContents (ASYNCHRONOUSCOMPOSITION as a b) =
        [CElem (Elem "ASYNCHRONOUSCOMPOSITION" (toAttrs as) (toContents a
                                                             ++ toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASYNCHRONOUSCOMPOSITION"]
        ; interior e $ return (ASYNCHRONOUSCOMPOSITION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ASYNCHRONOUSCOMPOSITION>, "++)
instance XmlAttributes ASYNCHRONOUSCOMPOSITION_Attrs where
    fromAttrs as =
        ASYNCHRONOUSCOMPOSITION_Attrs
          { aSYNCHRONOUSCOMPOSITIONPLACE = possibleA fromAttrToStr "PLACE" as
          , aSYNCHRONOUSCOMPOSITIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSYNCHRONOUSCOMPOSITIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (aSYNCHRONOUSCOMPOSITIONPARENS v)
        ]

instance HTypeable MULTISYNCHRONOUS where
    toHType x = Defined "MULTISYNCHRONOUS" [] []
instance XmlContent MULTISYNCHRONOUS where
    toContents (MULTISYNCHRONOUS as a b) =
        [CElem (Elem "MULTISYNCHRONOUS" (toAttrs as) (toContents a ++
                                                      toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MULTISYNCHRONOUS"]
        ; interior e $ return (MULTISYNCHRONOUS (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MULTISYNCHRONOUS>, "++)
instance XmlAttributes MULTISYNCHRONOUS_Attrs where
    fromAttrs as =
        MULTISYNCHRONOUS_Attrs
          { mULTISYNCHRONOUSPLACE = possibleA fromAttrToStr "PLACE" as
          , mULTISYNCHRONOUSPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mULTISYNCHRONOUSPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (mULTISYNCHRONOUSPARENS v)
        ]

instance HTypeable MULTIASYNCHRONOUS where
    toHType x = Defined "MULTIASYNCHRONOUS" [] []
instance XmlContent MULTIASYNCHRONOUS where
    toContents (MULTIASYNCHRONOUS as a b) =
        [CElem (Elem "MULTIASYNCHRONOUS" (toAttrs as) (toContents a ++
                                                       toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MULTIASYNCHRONOUS"]
        ; interior e $ return (MULTIASYNCHRONOUS (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MULTIASYNCHRONOUS>, "++)
instance XmlAttributes MULTIASYNCHRONOUS_Attrs where
    fromAttrs as =
        MULTIASYNCHRONOUS_Attrs
          { mULTIASYNCHRONOUSPLACE = possibleA fromAttrToStr "PLACE" as
          , mULTIASYNCHRONOUSPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mULTIASYNCHRONOUSPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (mULTIASYNCHRONOUSPARENS v)
        ]

instance HTypeable HIDING where
    toHType x = Defined "HIDING" [] []
instance XmlContent HIDING where
    toContents (HIDING as a b) =
        [CElem (Elem "HIDING" (toAttrs as) (toContents a ++
                                            toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["HIDING"]
        ; interior e $ return (HIDING (fromAttrs as)) `apply` parseContents
                       `apply` parseContents
        } `adjustErr` ("in <HIDING>, "++)
instance XmlAttributes HIDING_Attrs where
    fromAttrs as =
        HIDING_Attrs
          { hIDINGPLACE = possibleA fromAttrToStr "PLACE" as
          , hIDINGPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (hIDINGPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (hIDINGPARENS v)
        ]

instance HTypeable NEWOUTPUT where
    toHType x = Defined "NEWOUTPUT" [] []
instance XmlContent NEWOUTPUT where
    toContents (NEWOUTPUT as a b) =
        [CElem (Elem "NEWOUTPUT" (toAttrs as) (toContents a ++
                                               toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["NEWOUTPUT"]
        ; interior e $ return (NEWOUTPUT (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <NEWOUTPUT>, "++)
instance XmlAttributes NEWOUTPUT_Attrs where
    fromAttrs as =
        NEWOUTPUT_Attrs
          { nEWOUTPUTPLACE = possibleA fromAttrToStr "PLACE" as
          , nEWOUTPUTPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (nEWOUTPUTPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (nEWOUTPUTPARENS v)
        ]

instance HTypeable RENAMING where
    toHType x = Defined "RENAMING" [] []
instance XmlContent RENAMING where
    toContents (RENAMING as a b) =
        [CElem (Elem "RENAMING" (toAttrs as) (toContents a ++
                                              toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RENAMING"]
        ; interior e $ return (RENAMING (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <RENAMING>, "++)
instance XmlAttributes RENAMING_Attrs where
    fromAttrs as =
        RENAMING_Attrs
          { rENAMINGPLACE = possibleA fromAttrToStr "PLACE" as
          , rENAMINGPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rENAMINGPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (rENAMINGPARENS v)
        ]

instance HTypeable WITHMODULE where
    toHType x = Defined "WITHMODULE" [] []
instance XmlContent WITHMODULE where
    toContents (WITHMODULE as a b) =
        [CElem (Elem "WITHMODULE" (toAttrs as) (toContents a ++
                                                toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["WITHMODULE"]
        ; interior e $ return (WITHMODULE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <WITHMODULE>, "++)
instance XmlAttributes WITHMODULE_Attrs where
    fromAttrs as =
        WITHMODULE_Attrs
          { wITHMODULEPLACE = possibleA fromAttrToStr "PLACE" as
          , wITHMODULEPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (wITHMODULEPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (wITHMODULEPARENS v)
        ]

instance HTypeable NEWVARDECLS where
    toHType x = Defined "NEWVARDECLS" [] []
instance XmlContent NEWVARDECLS where
    toContents (NEWVARDECLS as a) =
        [CElem (Elem "NEWVARDECLS" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["NEWVARDECLS"]
        ; interior e $ return (NEWVARDECLS (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <NEWVARDECLS>, "++)
instance XmlAttributes NEWVARDECLS_Attrs where
    fromAttrs as =
        NEWVARDECLS_Attrs
          { nEWVARDECLSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (nEWVARDECLSPLACE v)
        ]

instance HTypeable RENAMES where
    toHType x = Defined "RENAMES" [] []
instance XmlContent RENAMES where
    toContents (RENAMES as a) =
        [CElem (Elem "RENAMES" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RENAMES"]
        ; interior e $ return (RENAMES (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <RENAMES>, "++)
instance XmlAttributes RENAMES_Attrs where
    fromAttrs as =
        RENAMES_Attrs
          { rENAMESPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rENAMESPLACE v)
        ]

instance HTypeable RENAME where
    toHType x = Defined "RENAME" [] []
instance XmlContent RENAME where
    toContents (RENAME as a b) =
        [CElem (Elem "RENAME" (toAttrs as) (toContents a ++
                                            toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RENAME"]
        ; interior e $ return (RENAME (fromAttrs as)) `apply` parseContents
                       `apply` parseContents
        } `adjustErr` ("in <RENAME>, "++)
instance XmlAttributes RENAME_Attrs where
    fromAttrs as =
        RENAME_Attrs
          { rENAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rENAMEPLACE v)
        ]

instance HTypeable MODULEINSTANCE where
    toHType x = Defined "MODULEINSTANCE" [] []
instance XmlContent MODULEINSTANCE where
    toContents (MODULEINSTANCE as a b) =
        [CElem (Elem "MODULEINSTANCE" (toAttrs as) (toContents a ++
                                                    toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULEINSTANCE"]
        ; interior e $ return (MODULEINSTANCE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MODULEINSTANCE>, "++)
instance XmlAttributes MODULEINSTANCE_Attrs where
    fromAttrs as =
        MODULEINSTANCE_Attrs
          { mODULEINSTANCEPLACE = possibleA fromAttrToStr "PLACE" as
          , mODULEINSTANCEPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULEINSTANCEPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (mODULEINSTANCEPARENS v)
        ]

instance HTypeable MODULENAME where
    toHType x = Defined "MODULENAME" [] []
instance XmlContent MODULENAME where
    toContents (MODULENAME as a) =
        [CElem (Elem "MODULENAME" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULENAME"]
        ; interior e $ return (MODULENAME (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <MODULENAME>, "++)
instance XmlAttributes MODULENAME_Attrs where
    fromAttrs as =
        MODULENAME_Attrs
          { mODULENAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULENAMEPLACE v)
        ]

instance HTypeable QUALIFIEDMODULENAME where
    toHType x = Defined "QUALIFIEDMODULENAME" [] []
instance XmlContent QUALIFIEDMODULENAME where
    toContents (QUALIFIEDMODULENAME as a) =
        [CElem (Elem "QUALIFIEDMODULENAME" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUALIFIEDMODULENAME"]
        ; interior e $ return (QUALIFIEDMODULENAME (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <QUALIFIEDMODULENAME>, "++)
instance XmlAttributes QUALIFIEDMODULENAME_Attrs where
    fromAttrs as =
        QUALIFIEDMODULENAME_Attrs
          { qUALIFIEDMODULENAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUALIFIEDMODULENAMEPLACE v)
        ]

instance HTypeable MODULEACTUALS where
    toHType x = Defined "MODULEACTUALS" [] []
instance XmlContent MODULEACTUALS where
    toContents (MODULEACTUALS as a) =
        [CElem (Elem "MODULEACTUALS" (toAttrs as) (concatMap toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULEACTUALS"]
        ; interior e $ return (MODULEACTUALS (fromAttrs as))
                       `apply` many parseContents
        } `adjustErr` ("in <MODULEACTUALS>, "++)
instance XmlAttributes MODULEACTUALS_Attrs where
    fromAttrs as =
        MODULEACTUALS_Attrs
          { mODULEACTUALSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULEACTUALSPLACE v)
        ]

instance HTypeable OBSERVEMODULE where
    toHType x = Defined "OBSERVEMODULE" [] []
instance XmlContent OBSERVEMODULE where
    toContents (OBSERVEMODULE as a b) =
        [CElem (Elem "OBSERVEMODULE" (toAttrs as) (toContents a ++
                                                   toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["OBSERVEMODULE"]
        ; interior e $ return (OBSERVEMODULE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <OBSERVEMODULE>, "++)
instance XmlAttributes OBSERVEMODULE_Attrs where
    fromAttrs as =
        OBSERVEMODULE_Attrs
          { oBSERVEMODULEPLACE = possibleA fromAttrToStr "PLACE" as
          , oBSERVEMODULEPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (oBSERVEMODULEPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (oBSERVEMODULEPARENS v)
        ]

instance HTypeable SCALARTYPE where
    toHType x = Defined "SCALARTYPE" [] []
instance XmlContent SCALARTYPE where
    toContents (SCALARTYPE as a) =
        [CElem (Elem "SCALARTYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SCALARTYPE"]
        ; interior e $ return (SCALARTYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <SCALARTYPE>, "++)
instance XmlAttributes SCALARTYPE_Attrs where
    fromAttrs as =
        SCALARTYPE_Attrs
          { sCALARTYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sCALARTYPEPLACE v)
        ]

instance HTypeable SCALARELEMENT where
    toHType x = Defined "SCALARELEMENT" [] []
instance XmlContent SCALARELEMENT where
    toContents (SCALARELEMENT as a) =
        [CElem (Elem "SCALARELEMENT" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SCALARELEMENT"]
        ; interior e $ return (SCALARELEMENT (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <SCALARELEMENT>, "++)
instance XmlAttributes SCALARELEMENT_Attrs where
    fromAttrs as =
        SCALARELEMENT_Attrs
          { sCALARELEMENTPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sCALARELEMENTPLACE v)
        ]

instance HTypeable DATATYPE where
    toHType x = Defined "DATATYPE" [] []
instance XmlContent DATATYPE where
    toContents (DATATYPE as a) =
        [CElem (Elem "DATATYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["DATATYPE"]
        ; interior e $ return (DATATYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <DATATYPE>, "++)
instance XmlAttributes DATATYPE_Attrs where
    fromAttrs as =
        DATATYPE_Attrs
          { dATATYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (dATATYPEPLACE v)
        ]

instance HTypeable CONSTRUCTOR where
    toHType x = Defined "CONSTRUCTOR" [] []
instance XmlContent CONSTRUCTOR where
    toContents (CONSTRUCTOR as a b) =
        [CElem (Elem "CONSTRUCTOR" (toAttrs as) (toContents a ++
                                                 concatMap toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONSTRUCTOR"]
        ; interior e $ return (CONSTRUCTOR (fromAttrs as))
                       `apply` parseContents `apply` many parseContents
        } `adjustErr` ("in <CONSTRUCTOR>, "++)
instance XmlAttributes CONSTRUCTOR_Attrs where
    fromAttrs as =
        CONSTRUCTOR_Attrs
          { cONSTRUCTORPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONSTRUCTORPLACE v)
        ]

instance HTypeable ACCESSOR where
    toHType x = Defined "ACCESSOR" [] []
instance XmlContent ACCESSOR where
    toContents (ACCESSOR as a b) =
        [CElem (Elem "ACCESSOR" (toAttrs as) (toContents a ++
                                              toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ACCESSOR"]
        ; interior e $ return (ACCESSOR (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ACCESSOR>, "++)
instance XmlAttributes ACCESSOR_Attrs where
    fromAttrs as =
        ACCESSOR_Attrs
          { aCCESSORPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aCCESSORPLACE v)
        ]

instance HTypeable TYPENAME where
    toHType x = Defined "TYPENAME" [] []
instance XmlContent TYPENAME where
    toContents (TYPENAME as a) =
        [CElem (Elem "TYPENAME" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TYPENAME"]
        ; interior e $ return (TYPENAME (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <TYPENAME>, "++)
instance XmlAttributes TYPENAME_Attrs where
    fromAttrs as =
        TYPENAME_Attrs
          { tYPENAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tYPENAMEPLACE v)
        ]

instance HTypeable QUALIFIEDTYPENAME where
    toHType x = Defined "QUALIFIEDTYPENAME" [] []
instance XmlContent QUALIFIEDTYPENAME where
    toContents (QUALIFIEDTYPENAME as a) =
        [CElem (Elem "QUALIFIEDTYPENAME" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUALIFIEDTYPENAME"]
        ; interior e $ return (QUALIFIEDTYPENAME (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <QUALIFIEDTYPENAME>, "++)
instance XmlAttributes QUALIFIEDTYPENAME_Attrs where
    fromAttrs as =
        QUALIFIEDTYPENAME_Attrs
          { qUALIFIEDTYPENAMEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUALIFIEDTYPENAMEPLACE v)
        ]

instance HTypeable SUBRANGE where
    toHType x = Defined "SUBRANGE" [] []
instance XmlContent SUBRANGE where
    toContents (SUBRANGE as a b) =
        [CElem (Elem "SUBRANGE" (toAttrs as) (toContents a ++
                                              toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SUBRANGE"]
        ; interior e $ return (SUBRANGE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <SUBRANGE>, "++)
instance XmlAttributes SUBRANGE_Attrs where
    fromAttrs as =
        SUBRANGE_Attrs
          { sUBRANGEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sUBRANGEPLACE v)
        ]

instance HTypeable ARRAYTYPE where
    toHType x = Defined "ARRAYTYPE" [] []
instance XmlContent ARRAYTYPE where
    toContents (ARRAYTYPE as a b) =
        [CElem (Elem "ARRAYTYPE" (toAttrs as) (toContents a ++
                                               toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ARRAYTYPE"]
        ; interior e $ return (ARRAYTYPE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ARRAYTYPE>, "++)
instance XmlAttributes ARRAYTYPE_Attrs where
    fromAttrs as =
        ARRAYTYPE_Attrs
          { aRRAYTYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aRRAYTYPEPLACE v)
        ]

instance HTypeable TUPLETYPE where
    toHType x = Defined "TUPLETYPE" [] []
instance XmlContent TUPLETYPE where
    toContents (TUPLETYPE as a) =
        [CElem (Elem "TUPLETYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TUPLETYPE"]
        ; interior e $ return (TUPLETYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <TUPLETYPE>, "++)
instance XmlAttributes TUPLETYPE_Attrs where
    fromAttrs as =
        TUPLETYPE_Attrs
          { tUPLETYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tUPLETYPEPLACE v)
        ]

instance HTypeable RECORDTYPE where
    toHType x = Defined "RECORDTYPE" [] []
instance XmlContent RECORDTYPE where
    toContents (RECORDTYPE as a) =
        [CElem (Elem "RECORDTYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RECORDTYPE"]
        ; interior e $ return (RECORDTYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <RECORDTYPE>, "++)
instance XmlAttributes RECORDTYPE_Attrs where
    fromAttrs as =
        RECORDTYPE_Attrs
          { rECORDTYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rECORDTYPEPLACE v)
        ]

instance HTypeable FIELDDECLARATION where
    toHType x = Defined "FIELDDECLARATION" [] []
instance XmlContent FIELDDECLARATION where
    toContents (FIELDDECLARATION as a b) =
        [CElem (Elem "FIELDDECLARATION" (toAttrs as) (toContents a ++
                                                      toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["FIELDDECLARATION"]
        ; interior e $ return (FIELDDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <FIELDDECLARATION>, "++)
instance XmlAttributes FIELDDECLARATION_Attrs where
    fromAttrs as =
        FIELDDECLARATION_Attrs
          { fIELDDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (fIELDDECLARATIONPLACE v)
        ]

instance HTypeable FUNCTIONTYPE where
    toHType x = Defined "FUNCTIONTYPE" [] []
instance XmlContent FUNCTIONTYPE where
    toContents (FUNCTIONTYPE as a b) =
        [CElem (Elem "FUNCTIONTYPE" (toAttrs as) (toContents a ++
                                                  toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["FUNCTIONTYPE"]
        ; interior e $ return (FUNCTIONTYPE (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <FUNCTIONTYPE>, "++)
instance XmlAttributes FUNCTIONTYPE_Attrs where
    fromAttrs as =
        FUNCTIONTYPE_Attrs
          { fUNCTIONTYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (fUNCTIONTYPEPLACE v)
        ]

instance HTypeable SUBTYPE where
    toHType x = Defined "SUBTYPE" [] []
instance XmlContent SUBTYPE where
    toContents (SUBTYPE as a) =
        [CElem (Elem "SUBTYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SUBTYPE"]
        ; interior e $ return (SUBTYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <SUBTYPE>, "++)
instance XmlAttributes SUBTYPE_Attrs where
    fromAttrs as =
        SUBTYPE_Attrs
          { sUBTYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sUBTYPEPLACE v)
        ]

instance HTypeable STATETYPE where
    toHType x = Defined "STATETYPE" [] []
instance XmlContent STATETYPE where
    toContents (STATETYPE as a) =
        [CElem (Elem "STATETYPE" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["STATETYPE"]
        ; interior e $ return (STATETYPE (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <STATETYPE>, "++)
instance XmlAttributes STATETYPE_Attrs where
    fromAttrs as =
        STATETYPE_Attrs
          { sTATETYPEPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sTATETYPEPLACE v)
        ]

instance HTypeable NEXTOPERATOR where
    toHType x = Defined "NEXTOPERATOR" [] []
instance XmlContent NEXTOPERATOR where
    toContents (NEXTOPERATOR as a) =
        [CElem (Elem "NEXTOPERATOR" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["NEXTOPERATOR"]
        ; interior e $ return (NEXTOPERATOR (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <NEXTOPERATOR>, "++)
instance XmlAttributes NEXTOPERATOR_Attrs where
    fromAttrs as =
        NEXTOPERATOR_Attrs
          { nEXTOPERATORPLACE = possibleA fromAttrToStr "PLACE" as
          , nEXTOPERATORPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (nEXTOPERATORPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (nEXTOPERATORPARENS v)
        ]

instance HTypeable NAMEEXPR where
    toHType x = Defined "NAMEEXPR" [] []
instance XmlContent NAMEEXPR where
    toContents (NAMEEXPR as a) =
        [CElem (Elem "NAMEEXPR" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["NAMEEXPR"]
        ; interior e $ return (NAMEEXPR (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <NAMEEXPR>, "++)
instance XmlAttributes NAMEEXPR_Attrs where
    fromAttrs as =
        NAMEEXPR_Attrs
          { nAMEEXPRPLACE = possibleA fromAttrToStr "PLACE" as
          , nAMEEXPRPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (nAMEEXPRPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (nAMEEXPRPARENS v)
        ]

instance HTypeable QUALIFIEDNAMEEXPR where
    toHType x = Defined "QUALIFIEDNAMEEXPR" [] []
instance XmlContent QUALIFIEDNAMEEXPR where
    toContents (QUALIFIEDNAMEEXPR as a) =
        [CElem (Elem "QUALIFIEDNAMEEXPR" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUALIFIEDNAMEEXPR"]
        ; interior e $ return (QUALIFIEDNAMEEXPR (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <QUALIFIEDNAMEEXPR>, "++)
instance XmlAttributes QUALIFIEDNAMEEXPR_Attrs where
    fromAttrs as =
        QUALIFIEDNAMEEXPR_Attrs
          { qUALIFIEDNAMEEXPRPLACE = possibleA fromAttrToStr "PLACE" as
          , qUALIFIEDNAMEEXPRPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUALIFIEDNAMEEXPRPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (qUALIFIEDNAMEEXPRPARENS v)
        ]

instance HTypeable APPLICATION where
    toHType x = Defined "APPLICATION" [] []
instance XmlContent APPLICATION where
    toContents (APPLICATION as a b) =
        [CElem (Elem "APPLICATION" (toAttrs as) (toContents a ++
                                                 toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["APPLICATION"]
        ; interior e $ return (APPLICATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <APPLICATION>, "++)
instance XmlAttributes APPLICATION_Attrs where
    fromAttrs as =
        APPLICATION_Attrs
          { aPPLICATIONPLACE = possibleA fromAttrToStr "PLACE" as
          , aPPLICATIONINFIX = defaultA fromAttrToTyp APPLICATION_INFIX_NO "INFIX" as
          , aPPLICATIONUNARY = defaultA fromAttrToTyp APPLICATION_UNARY_NO "UNARY" as
          , aPPLICATIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aPPLICATIONPLACE v)
        , defaultToAttr toAttrFrTyp "INFIX" (aPPLICATIONINFIX v)
        , defaultToAttr toAttrFrTyp "UNARY" (aPPLICATIONUNARY v)
        , defaultToAttr toAttrFrStr "PARENS" (aPPLICATIONPARENS v)
        ]

instance XmlAttrType APPLICATION_INFIX where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just APPLICATION_INFIX_YES
            translate "NO" = Just APPLICATION_INFIX_NO
            translate _ = Nothing
    toAttrFrTyp n APPLICATION_INFIX_YES = Just (n, str2attr "YES")
    toAttrFrTyp n APPLICATION_INFIX_NO = Just (n, str2attr "NO")

instance XmlAttrType APPLICATION_UNARY where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just APPLICATION_UNARY_YES
            translate "NO" = Just APPLICATION_UNARY_NO
            translate _ = Nothing
    toAttrFrTyp n APPLICATION_UNARY_YES = Just (n, str2attr "YES")
    toAttrFrTyp n APPLICATION_UNARY_NO = Just (n, str2attr "NO")

instance HTypeable ARRAYSELECTION where
    toHType x = Defined "ARRAYSELECTION" [] []
instance XmlContent ARRAYSELECTION where
    toContents (ARRAYSELECTION as a b) =
        [CElem (Elem "ARRAYSELECTION" (toAttrs as) (toContents a ++
                                                    toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ARRAYSELECTION"]
        ; interior e $ return (ARRAYSELECTION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ARRAYSELECTION>, "++)
instance XmlAttributes ARRAYSELECTION_Attrs where
    fromAttrs as =
        ARRAYSELECTION_Attrs
          { aRRAYSELECTIONPLACE = possibleA fromAttrToStr "PLACE" as
          , aRRAYSELECTIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aRRAYSELECTIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (aRRAYSELECTIONPARENS v)
        ]

instance HTypeable RECORDSELECTION where
    toHType x = Defined "RECORDSELECTION" [] []
instance XmlContent RECORDSELECTION where
    toContents (RECORDSELECTION as a b) =
        [CElem (Elem "RECORDSELECTION" (toAttrs as) (toContents a ++
                                                     toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RECORDSELECTION"]
        ; interior e $ return (RECORDSELECTION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <RECORDSELECTION>, "++)
instance XmlAttributes RECORDSELECTION_Attrs where
    fromAttrs as =
        RECORDSELECTION_Attrs
          { rECORDSELECTIONPLACE = possibleA fromAttrToStr "PLACE" as
          , rECORDSELECTIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rECORDSELECTIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (rECORDSELECTIONPARENS v)
        ]

instance HTypeable TUPLESELECTION where
    toHType x = Defined "TUPLESELECTION" [] []
instance XmlContent TUPLESELECTION where
    toContents (TUPLESELECTION as a b) =
        [CElem (Elem "TUPLESELECTION" (toAttrs as) (toContents a ++
                                                    toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TUPLESELECTION"]
        ; interior e $ return (TUPLESELECTION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <TUPLESELECTION>, "++)
instance XmlAttributes TUPLESELECTION_Attrs where
    fromAttrs as =
        TUPLESELECTION_Attrs
          { tUPLESELECTIONPLACE = possibleA fromAttrToStr "PLACE" as
          , tUPLESELECTIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tUPLESELECTIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (tUPLESELECTIONPARENS v)
        ]

instance HTypeable RECORDLITERAL where
    toHType x = Defined "RECORDLITERAL" [] []
instance XmlContent RECORDLITERAL where
    toContents (RECORDLITERAL as a) =
        [CElem (Elem "RECORDLITERAL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RECORDLITERAL"]
        ; interior e $ return (RECORDLITERAL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <RECORDLITERAL>, "++)
instance XmlAttributes RECORDLITERAL_Attrs where
    fromAttrs as =
        RECORDLITERAL_Attrs
          { rECORDLITERALPLACE = possibleA fromAttrToStr "PLACE" as
          , rECORDLITERALPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rECORDLITERALPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (rECORDLITERALPARENS v)
        ]

instance HTypeable RECORDENTRY where
    toHType x = Defined "RECORDENTRY" [] []
instance XmlContent RECORDENTRY where
    toContents (RECORDENTRY as a b) =
        [CElem (Elem "RECORDENTRY" (toAttrs as) (toContents a ++
                                                 toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["RECORDENTRY"]
        ; interior e $ return (RECORDENTRY (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <RECORDENTRY>, "++)
instance XmlAttributes RECORDENTRY_Attrs where
    fromAttrs as =
        RECORDENTRY_Attrs
          { rECORDENTRYPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (rECORDENTRYPLACE v)
        ]

instance HTypeable TUPLELITERAL where
    toHType x = Defined "TUPLELITERAL" [] []
instance XmlContent TUPLELITERAL where
    toContents (TUPLELITERAL as a) =
        [CElem (Elem "TUPLELITERAL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TUPLELITERAL"]
        ; interior e $ return (TUPLELITERAL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <TUPLELITERAL>, "++)
instance XmlAttributes TUPLELITERAL_Attrs where
    fromAttrs as =
        TUPLELITERAL_Attrs
          { tUPLELITERALPLACE = possibleA fromAttrToStr "PLACE" as
          , tUPLELITERALPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tUPLELITERALPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (tUPLELITERALPARENS v)
        ]

instance HTypeable UPDATEEXPRESSION where
    toHType x = Defined "UPDATEEXPRESSION" [] []
instance XmlContent UPDATEEXPRESSION where
    toContents (UPDATEEXPRESSION as a b c) =
        [CElem (Elem "UPDATEEXPRESSION" (toAttrs as) (toContents a ++
                                                      toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["UPDATEEXPRESSION"]
        ; interior e $ return (UPDATEEXPRESSION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <UPDATEEXPRESSION>, "++)
instance XmlAttributes UPDATEEXPRESSION_Attrs where
    fromAttrs as =
        UPDATEEXPRESSION_Attrs
          { uPDATEEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          , uPDATEEXPRESSIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (uPDATEEXPRESSIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (uPDATEEXPRESSIONPARENS v)
        ]

instance HTypeable DEPTH where
    toHType x = Defined "DEPTH" [] []
instance XmlContent DEPTH where
    toContents (DEPTH a) =
        [CElem (Elem "DEPTH" [] (toText a)) ()]
    parseContents = do
        { e@(Elem _ [] _) <- element ["DEPTH"]
        ; interior e $ return (DEPTH) `apply` (text `onFail` return "")
        } `adjustErr` ("in <DEPTH>, "++)

instance HTypeable ARRAYLITERAL where
    toHType x = Defined "ARRAYLITERAL" [] []
instance XmlContent ARRAYLITERAL where
    toContents (ARRAYLITERAL as a b) =
        [CElem (Elem "ARRAYLITERAL" (toAttrs as) (toContents a ++
                                                  toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ARRAYLITERAL"]
        ; interior e $ return (ARRAYLITERAL (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ARRAYLITERAL>, "++)
instance XmlAttributes ARRAYLITERAL_Attrs where
    fromAttrs as =
        ARRAYLITERAL_Attrs
          { aRRAYLITERALPLACE = possibleA fromAttrToStr "PLACE" as
          , aRRAYLITERALPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aRRAYLITERALPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (aRRAYLITERALPARENS v)
        ]

instance HTypeable INDEXVARDECL where
    toHType x = Defined "INDEXVARDECL" [] []
instance XmlContent INDEXVARDECL where
    toContents (INDEXVARDECL as a b) =
        [CElem (Elem "INDEXVARDECL" (toAttrs as) (toContents a ++
                                                  toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["INDEXVARDECL"]
        ; interior e $ return (INDEXVARDECL (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <INDEXVARDECL>, "++)
instance XmlAttributes INDEXVARDECL_Attrs where
    fromAttrs as =
        INDEXVARDECL_Attrs
          { iNDEXVARDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (iNDEXVARDECLPLACE v)
        ]

instance HTypeable LAMBDAABSTRACTION where
    toHType x = Defined "LAMBDAABSTRACTION" [] []
instance XmlContent LAMBDAABSTRACTION where
    toContents (LAMBDAABSTRACTION as a b) =
        [CElem (Elem "LAMBDAABSTRACTION" (toAttrs as) (toContents a ++
                                                       toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LAMBDAABSTRACTION"]
        ; interior e $ return (LAMBDAABSTRACTION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <LAMBDAABSTRACTION>, "++)
instance XmlAttributes LAMBDAABSTRACTION_Attrs where
    fromAttrs as =
        LAMBDAABSTRACTION_Attrs
          { lAMBDAABSTRACTIONPLACE = possibleA fromAttrToStr "PLACE" as
          , lAMBDAABSTRACTIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lAMBDAABSTRACTIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (lAMBDAABSTRACTIONPARENS v)
        ]

instance HTypeable QUANTIFIEDEXPRESSION where
    toHType x = Defined "QUANTIFIEDEXPRESSION" [] []
instance XmlContent QUANTIFIEDEXPRESSION where
    toContents (QUANTIFIEDEXPRESSION as a b c) =
        [CElem (Elem "QUANTIFIEDEXPRESSION" (toAttrs as) (toContents a ++
                                                          toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUANTIFIEDEXPRESSION"]
        ; interior e $ return (QUANTIFIEDEXPRESSION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <QUANTIFIEDEXPRESSION>, "++)
instance XmlAttributes QUANTIFIEDEXPRESSION_Attrs where
    fromAttrs as =
        QUANTIFIEDEXPRESSION_Attrs
          { qUANTIFIEDEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          , qUANTIFIEDEXPRESSIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUANTIFIEDEXPRESSIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (qUANTIFIEDEXPRESSIONPARENS v)
        ]

instance HTypeable QUANTIFIER where
    toHType x = Defined "QUANTIFIER" [] []
instance XmlContent QUANTIFIER where
    toContents (QUANTIFIER as a) =
        [CElem (Elem "QUANTIFIER" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUANTIFIER"]
        ; interior e $ return (QUANTIFIER (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <QUANTIFIER>, "++)
instance XmlAttributes QUANTIFIER_Attrs where
    fromAttrs as =
        QUANTIFIER_Attrs
          { qUANTIFIERPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUANTIFIERPLACE v)
        ]

instance HTypeable LETEXPRESSION where
    toHType x = Defined "LETEXPRESSION" [] []
instance XmlContent LETEXPRESSION where
    toContents (LETEXPRESSION as a b) =
        [CElem (Elem "LETEXPRESSION" (toAttrs as) (toContents a ++
                                                   toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LETEXPRESSION"]
        ; interior e $ return (LETEXPRESSION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <LETEXPRESSION>, "++)
instance XmlAttributes LETEXPRESSION_Attrs where
    fromAttrs as =
        LETEXPRESSION_Attrs
          { lETEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          , lETEXPRESSIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lETEXPRESSIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (lETEXPRESSIONPARENS v)
        ]

instance HTypeable LETDECLARATIONS where
    toHType x = Defined "LETDECLARATIONS" [] []
instance XmlContent LETDECLARATIONS where
    toContents (LETDECLARATIONS as a) =
        [CElem (Elem "LETDECLARATIONS" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LETDECLARATIONS"]
        ; interior e $ return (LETDECLARATIONS (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <LETDECLARATIONS>, "++)
instance XmlAttributes LETDECLARATIONS_Attrs where
    fromAttrs as =
        LETDECLARATIONS_Attrs
          { lETDECLARATIONSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lETDECLARATIONSPLACE v)
        ]

instance HTypeable LETDECLARATION where
    toHType x = Defined "LETDECLARATION" [] []
instance XmlContent LETDECLARATION where
    toContents (LETDECLARATION as a b c) =
        [CElem (Elem "LETDECLARATION" (toAttrs as) (toContents a ++
                                                    toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["LETDECLARATION"]
        ; interior e $ return (LETDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <LETDECLARATION>, "++)
instance XmlAttributes LETDECLARATION_Attrs where
    fromAttrs as =
        LETDECLARATION_Attrs
          { lETDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (lETDECLARATIONPLACE v)
        ]

instance HTypeable SETPREDEXPRESSION where
    toHType x = Defined "SETPREDEXPRESSION" [] []
instance XmlContent SETPREDEXPRESSION where
    toContents (SETPREDEXPRESSION as a b c) =
        [CElem (Elem "SETPREDEXPRESSION" (toAttrs as) (toContents a ++
                                                       toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SETPREDEXPRESSION"]
        ; interior e $ return (SETPREDEXPRESSION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <SETPREDEXPRESSION>, "++)
instance XmlAttributes SETPREDEXPRESSION_Attrs where
    fromAttrs as =
        SETPREDEXPRESSION_Attrs
          { sETPREDEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          , sETPREDEXPRESSIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sETPREDEXPRESSIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (sETPREDEXPRESSIONPARENS v)
        ]

instance HTypeable SETLISTEXPRESSION where
    toHType x = Defined "SETLISTEXPRESSION" [] []
instance XmlContent SETLISTEXPRESSION where
    toContents (SETLISTEXPRESSION as a) =
        [CElem (Elem "SETLISTEXPRESSION" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["SETLISTEXPRESSION"]
        ; interior e $ return (SETLISTEXPRESSION (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <SETLISTEXPRESSION>, "++)
instance XmlAttributes SETLISTEXPRESSION_Attrs where
    fromAttrs as =
        SETLISTEXPRESSION_Attrs
          { sETLISTEXPRESSIONPLACE = possibleA fromAttrToStr "PLACE" as
          , sETLISTEXPRESSIONPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sETLISTEXPRESSIONPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (sETLISTEXPRESSIONPARENS v)
        ]

instance HTypeable CONDITIONAL where
    toHType x = Defined "CONDITIONAL" [] []
instance XmlContent CONDITIONAL where
    toContents (CONDITIONAL as a b c) =
        [CElem (Elem "CONDITIONAL" (toAttrs as) (toContents a ++
                                                 toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["CONDITIONAL"]
        ; interior e $ return (CONDITIONAL (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <CONDITIONAL>, "++)
instance XmlAttributes CONDITIONAL_Attrs where
    fromAttrs as =
        CONDITIONAL_Attrs
          { cONDITIONALPLACE = possibleA fromAttrToStr "PLACE" as
          , cONDITIONALELSIF = defaultA fromAttrToTyp CONDITIONAL_ELSIF_NO "ELSIF" as
          , cONDITIONALPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (cONDITIONALPLACE v)
        , defaultToAttr toAttrFrTyp "ELSIF" (cONDITIONALELSIF v)
        , defaultToAttr toAttrFrStr "PARENS" (cONDITIONALPARENS v)
        ]

instance XmlAttrType CONDITIONAL_ELSIF where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just CONDITIONAL_ELSIF_YES
            translate "NO" = Just CONDITIONAL_ELSIF_NO
            translate _ = Nothing
    toAttrFrTyp n CONDITIONAL_ELSIF_YES = Just (n, str2attr "YES")
    toAttrFrTyp n CONDITIONAL_ELSIF_NO = Just (n, str2attr "NO")

instance HTypeable MODINIT where
    toHType x = Defined "MODINIT" [] []
instance XmlContent MODINIT where
    toContents (MODINIT as a) =
        [CElem (Elem "MODINIT" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODINIT"]
        ; interior e $ return (MODINIT (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <MODINIT>, "++)
instance XmlAttributes MODINIT_Attrs where
    fromAttrs as =
        MODINIT_Attrs
          { mODINITPLACE = possibleA fromAttrToStr "PLACE" as
          , mODINITPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODINITPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (mODINITPARENS v)
        ]

instance HTypeable MODTRANS where
    toHType x = Defined "MODTRANS" [] []
instance XmlContent MODTRANS where
    toContents (MODTRANS as a) =
        [CElem (Elem "MODTRANS" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODTRANS"]
        ; interior e $ return (MODTRANS (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <MODTRANS>, "++)
instance XmlAttributes MODTRANS_Attrs where
    fromAttrs as =
        MODTRANS_Attrs
          { mODTRANSPLACE = possibleA fromAttrToStr "PLACE" as
          , mODTRANSPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODTRANSPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (mODTRANSPARENS v)
        ]

instance HTypeable NUMERAL where
    toHType x = Defined "NUMERAL" [] []
instance XmlContent NUMERAL where
    toContents (NUMERAL as a) =
        [CElem (Elem "NUMERAL" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["NUMERAL"]
        ; interior e $ return (NUMERAL (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <NUMERAL>, "++)
instance XmlAttributes NUMERAL_Attrs where
    fromAttrs as =
        NUMERAL_Attrs
          { nUMERALPLACE = possibleA fromAttrToStr "PLACE" as
          , nUMERALPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (nUMERALPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (nUMERALPARENS v)
        ]

instance HTypeable STRINGEXPR where
    toHType x = Defined "STRINGEXPR" [] []
instance XmlContent STRINGEXPR where
    toContents (STRINGEXPR as a) =
        [CElem (Elem "STRINGEXPR" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["STRINGEXPR"]
        ; interior e $ return (STRINGEXPR (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <STRINGEXPR>, "++)
instance XmlAttributes STRINGEXPR_Attrs where
    fromAttrs as =
        STRINGEXPR_Attrs
          { sTRINGEXPRPLACE = possibleA fromAttrToStr "PLACE" as
          , sTRINGEXPRPARENS = defaultA fromAttrToStr "0" "PARENS" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (sTRINGEXPRPLACE v)
        , defaultToAttr toAttrFrStr "PARENS" (sTRINGEXPRPARENS v)
        ]

instance HTypeable VARDECL where
    toHType x = Defined "VARDECL" [] []
instance XmlContent VARDECL where
    toContents (VARDECL as a b) =
        [CElem (Elem "VARDECL" (toAttrs as) (toContents a ++
                                             toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["VARDECL"]
        ; interior e $ return (VARDECL (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <VARDECL>, "++)
instance XmlAttributes VARDECL_Attrs where
    fromAttrs as =
        VARDECL_Attrs
          { vARDECLPLACE = possibleA fromAttrToStr "PLACE" as
          , vARDECLCHAIN = defaultA fromAttrToTyp VARDECL_CHAIN_NO "CHAIN" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (vARDECLPLACE v)
        , defaultToAttr toAttrFrTyp "CHAIN" (vARDECLCHAIN v)
        ]

instance XmlAttrType VARDECL_CHAIN where
    fromAttrToTyp n (n',v)
        | n==n'     = translate (attr2str v)
        | otherwise = Nothing
      where translate "YES" = Just VARDECL_CHAIN_YES
            translate "NO" = Just VARDECL_CHAIN_NO
            translate _ = Nothing
    toAttrFrTyp n VARDECL_CHAIN_YES = Just (n, str2attr "YES")
    toAttrFrTyp n VARDECL_CHAIN_NO = Just (n, str2attr "NO")

instance HTypeable TYPEDECL where
    toHType x = Defined "TYPEDECL" [] []
instance XmlContent TYPEDECL where
    toContents (TYPEDECL as a) =
        [CElem (Elem "TYPEDECL" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["TYPEDECL"]
        ; interior e $ return (TYPEDECL (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <TYPEDECL>, "++)
instance XmlAttributes TYPEDECL_Attrs where
    fromAttrs as =
        TYPEDECL_Attrs
          { tYPEDECLPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (tYPEDECLPLACE v)
        ]

instance HTypeable IDENTIFIERS where
    toHType x = Defined "IDENTIFIERS" [] []
instance XmlContent IDENTIFIERS where
    toContents (IDENTIFIERS as a) =
        [CElem (Elem "IDENTIFIERS" (toAttrs as) (toContents a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["IDENTIFIERS"]
        ; interior e $ return (IDENTIFIERS (fromAttrs as))
                       `apply` parseContents
        } `adjustErr` ("in <IDENTIFIERS>, "++)
instance XmlAttributes IDENTIFIERS_Attrs where
    fromAttrs as =
        IDENTIFIERS_Attrs
          { iDENTIFIERSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (iDENTIFIERSPLACE v)
        ]

instance HTypeable IDENTIFIER where
    toHType x = Defined "IDENTIFIER" [] []
instance XmlContent IDENTIFIER where
    toContents (IDENTIFIER as a) =
        [CElem (Elem "IDENTIFIER" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["IDENTIFIER"]
        ; interior e $ return (IDENTIFIER (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <IDENTIFIER>, "++)
instance XmlAttributes IDENTIFIER_Attrs where
    fromAttrs as =
        IDENTIFIER_Attrs
          { iDENTIFIERPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (iDENTIFIERPLACE v)
        ]

instance HTypeable ASSERTIONDECLARATION where
    toHType x = Defined "ASSERTIONDECLARATION" [] []
instance XmlContent ASSERTIONDECLARATION where
    toContents (ASSERTIONDECLARATION as a b c) =
        [CElem (Elem "ASSERTIONDECLARATION" (toAttrs as) (toContents a ++
                                                          toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASSERTIONDECLARATION"]
        ; interior e $ return (ASSERTIONDECLARATION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ASSERTIONDECLARATION>, "++)
instance XmlAttributes ASSERTIONDECLARATION_Attrs where
    fromAttrs as =
        ASSERTIONDECLARATION_Attrs
          { aSSERTIONDECLARATIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSSERTIONDECLARATIONPLACE v)
        ]

instance HTypeable ASSERTIONFORM where
    toHType x = Defined "ASSERTIONFORM" [] []
instance XmlContent ASSERTIONFORM where
    toContents (ASSERTIONFORM as a) =
        [CElem (Elem "ASSERTIONFORM" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASSERTIONFORM"]
        ; interior e $ return (ASSERTIONFORM (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <ASSERTIONFORM>, "++)
instance XmlAttributes ASSERTIONFORM_Attrs where
    fromAttrs as =
        ASSERTIONFORM_Attrs
          { aSSERTIONFORMPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSSERTIONFORMPLACE v)
        ]

instance HTypeable ASSERTIONPROPOSITION where
    toHType x = Defined "ASSERTIONPROPOSITION" [] []
instance XmlContent ASSERTIONPROPOSITION where
    toContents (ASSERTIONPROPOSITION as a b) =
        [CElem (Elem "ASSERTIONPROPOSITION" (toAttrs as) (toContents a ++
                                                          toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASSERTIONPROPOSITION"]
        ; interior e $ return (ASSERTIONPROPOSITION (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <ASSERTIONPROPOSITION>, "++)
instance XmlAttributes ASSERTIONPROPOSITION_Attrs where
    fromAttrs as =
        ASSERTIONPROPOSITION_Attrs
          { aSSERTIONPROPOSITIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSSERTIONPROPOSITIONPLACE v)
        ]

instance HTypeable ASSERTIONOPERATOR where
    toHType x = Defined "ASSERTIONOPERATOR" [] []
instance XmlContent ASSERTIONOPERATOR where
    toContents (ASSERTIONOPERATOR as a) =
        [CElem (Elem "ASSERTIONOPERATOR" (toAttrs as) (toText a)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["ASSERTIONOPERATOR"]
        ; interior e $ return (ASSERTIONOPERATOR (fromAttrs as))
                       `apply` (text `onFail` return "")
        } `adjustErr` ("in <ASSERTIONOPERATOR>, "++)
instance XmlAttributes ASSERTIONOPERATOR_Attrs where
    fromAttrs as =
        ASSERTIONOPERATOR_Attrs
          { aSSERTIONOPERATORPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (aSSERTIONOPERATORPLACE v)
        ]

instance HTypeable QUANTIFIEDASSERTION where
    toHType x = Defined "QUANTIFIEDASSERTION" [] []
instance XmlContent QUANTIFIEDASSERTION where
    toContents (QUANTIFIEDASSERTION as a b c) =
        [CElem (Elem "QUANTIFIEDASSERTION" (toAttrs as) (toContents a ++
                                                         toContents b ++ toContents c)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["QUANTIFIEDASSERTION"]
        ; interior e $ return (QUANTIFIEDASSERTION (fromAttrs as))
                       `apply` parseContents `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <QUANTIFIEDASSERTION>, "++)
instance XmlAttributes QUANTIFIEDASSERTION_Attrs where
    fromAttrs as =
        QUANTIFIEDASSERTION_Attrs
          { qUANTIFIEDASSERTIONPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (qUANTIFIEDASSERTIONPLACE v)
        ]

instance HTypeable MODULEMODELS where
    toHType x = Defined "MODULEMODELS" [] []
instance XmlContent MODULEMODELS where
    toContents (MODULEMODELS as a b) =
        [CElem (Elem "MODULEMODELS" (toAttrs as) (toContents a ++
                                                  toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULEMODELS"]
        ; interior e $ return (MODULEMODELS (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MODULEMODELS>, "++)
instance XmlAttributes MODULEMODELS_Attrs where
    fromAttrs as =
        MODULEMODELS_Attrs
          { mODULEMODELSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULEMODELSPLACE v)
        ]

instance HTypeable MODULEIMPLEMENTS where
    toHType x = Defined "MODULEIMPLEMENTS" [] []
instance XmlContent MODULEIMPLEMENTS where
    toContents (MODULEIMPLEMENTS as a b) =
        [CElem (Elem "MODULEIMPLEMENTS" (toAttrs as) (toContents a ++
                                                      toContents b)) ()]
    parseContents = do
        { e@(Elem _ as _) <- element ["MODULEIMPLEMENTS"]
        ; interior e $ return (MODULEIMPLEMENTS (fromAttrs as))
                       `apply` parseContents `apply` parseContents
        } `adjustErr` ("in <MODULEIMPLEMENTS>, "++)
instance XmlAttributes MODULEIMPLEMENTS_Attrs where
    fromAttrs as =
        MODULEIMPLEMENTS_Attrs
          { mODULEIMPLEMENTSPLACE = possibleA fromAttrToStr "PLACE" as
          }
    toAttrs v = catMaybes
        [ maybeToAttr toAttrFrStr "PLACE" (mODULEIMPLEMENTSPLACE v)
        ]



{-Done-}
